{
    "docs": [
        {
            "location": "/",
            "text": "Traffic Server ingress controller\n\n\nWARNING: This is alpha code, do not use it in production.\n  (If you do,\nplease report bugs.)\n\n\nTraffic Server\n is a high-performance,\nextensible HTTP proxy server with a rich feature set, including TLS termination,\ncaching, and edge-side includes (ESI).  This plugin allows Traffic Server to\nact as an \nIngress\n controller for\n\nKubernetes\n clusters, providing the reverse proxy that\nallows HTTP requests from the Internet to reach Kubernetes pods.\n\n\nThe controller is provided as C source code and as a pre-built Docker image.\nIf you want to add Kubernetes support to an existing instance of TS, you should\nbuild the plugin from source.  If you want to deploy TS inside a Kubernetes\ncluster, you can use the pre-built Docker image.\n\n\nQuick start\n\n\nTo deploy the image on an existing Kubernetes 1.6 (or later) cluster:\n\n\n$ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-rbac.yaml | kubectl apply -f -\n$ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-deployment.yaml | kubectl apply -f -\n\n\n\n\n(If you're using 1.5 or earlier, you can still use \nexample-deployment.yaml\n,\nbut if you need RBAC support you will need to convert \nexample-rbac.yaml\n to use\nthe old alpha RBAC API.)\n\n\nThis will start two copies of Traffic Server, each with an emptyDir volume for\ncache storage, listening on node ports 30080 (http) and 30443 (https).   You can\nconfigure an external load balancer of some sort to route incoming traffic to\nthose ports, or use Kubernetes'\n\nkeepalived-vip\n\nto manage a virtual IP address on your cluster.\n\n\nFor more detailed installation instructions, see the documentation for\n\nbuilding from source\n or \nDeploying on Kubernetes\n.\n\n\nFeatures\n\n\nThe controller provides the following features:\n\n\n\n\nFull support for Ingress resources, including many annotations used by other\n  controller implementations;\n\n\nHTTP/2, including server push;\n\n\nWebSockets;\n\n\nTLS termination, configured in the Ingress resource using Kubernetes Secrets;\n\n\nEmulation of the nginx Ingress controller (for services that require it,\n  e.g. kube-lego);\n\n\nFlexible HTTP caching, including:\n\n\nCache lifetime controlled by \nCache-Control\n or \nExpires\n headers;\n\n\nManipulation of outgoing Cache-Control;\n\n\nRemoval from the cache of individual pages or all pages at once;\n\n\nAlternatives (HTTP Vary);\n\n\nIgnoring URL parameters and cookies which do not affect page content.\n\n\n\n\n\n\nHTTP compression (gzip and Brotli);\n\n\nAuthorization using HTTP Basic authentication or client IP address;\n\n\nA complete, configurable CORS implementation;\n\n\nProxying to external (non-Kubernetes) services using Ingress resources;\n\n\nESI (Edge-Side Includes).\n\n\n\n\nPlanned features\n\n\nA feature being listed here indicates we are interested in implementing it, but\nprovides no guarantee that it will be implemented within any particular time\nframe, or ever.\n\n\nIf you would like to see a particular feature supported, whether it's on this\nlist or not, please\n\nopen a Github issue\n.\n\n\n\n\nTLS client certificate authentication.\n\n\nClient session affinity\n\n\nProxy protocol\n\n\nRate limiting\n\n\nSSL passthrough\n\n\nGlobal / default configuration\n\n\nHSTS preload support (in any case, rewrite the HSTS support as it will be\n  removed from TS core in some later release)\n\n\nCustom error bodies\n\n\nSupport \nlibslz\n as an alternative to zlib.\n\n\nImprove API watch support by first retrieving all objects, then watching with\n  resourceVersion.\n\n\nWildcard cache purging.\n\n\n\n\nRelease history\n\n\n\n\n\n\n1.0.0-alpha8 (unreleased):\n\n\n\n\nFeature: HTTP/2 Server Push was implemented.\n\n\n\n\n\n\n\n\n1.0.0-alpha7:\n\n\n\n\nImprovement: The Traffic Server version in the Docker image has been\n    upgraded from 7.0.0 to 7.1.x (prerelease).\n\n\nImprovement: The hash tree implementation has been replaced with a radix\n    tree, reducing memory use for small clusters and providing better (and\n    more predictable) performance for large clusters.\n\n\nBug fix: A synthetic response could cause a crash.\n\n\nBug fix: An incorrect Cookie header could be sent to the origin.\n\n\nBug fix: An incorrect Content-Encoding header could be sent to the client\n    if the client supported compression but the response object was not\n    compressed.\n\n\n\n\n\n\n\n\n1.0.0-alpha6:\n\n\n\n\nIncompatible change: The behaviour of the \napp-root\n annotation was\n    changed to match the behaviour of other Ingress controllers.\n\n\nIncompatible change: Several annotations were moved from\n    \ningress.torchbox.com\n to \ningress.kubernetes.io\n to improve\n     compatibility among Ingress controllers.\n\n\nFeature: The \ningress.kubernetes.io/read-response-timeout\n annotation\n    was implemented.\n\n\nFeature: CORS annotations were implemented.\n\n\nFeature: HTTP compression was implemented.\n\n\nFeature: For Ingress resources with caching enabled, an \nX-Cache-Status\n\n    header is returned in the response, indicating whether the request was\n    cached and the current cache generation.\n\n\nFeature: The \ncache-ignore-cookies\n annotation was implemented.\n\n\nBug fix: With certain combinations of OpenSSL and Traffic Server versions,\n    a TLS request for an unknown host could hang indefinitely instead of\n    returning an error.\n\n\n\n\n\n\n\n\n1.0.0-alpha5:\n\n\n\n\nIncompatible change: The \ningress.torchbox.com/auth-address-list\n\n    annotation was renamed to \ningress.torchbox.com/whitelist-source-range\n,\n    and is now comma-delimited, for compatibility with other Ingress\n    controllers.\n\n\nFeature: Support Ingress classes.\n\n\nFeature: The X-Forwarded-Proto header is now (optionally) sent to the\n    backend.\n\n\nFeature: The \ncache-whitelist-params\n and \ncache-ignore-params\n\n    annotations were implemented.\n\n\nFeature: The \ntls_verify\n configuration option was added.\n\n\nImprovement: The API server connection code was reimplemented using cURL,\n    making it more reliable and featureful.\n\n\nBug fix: TLS redirects with an empty URL path could crash.\n\n\nBug fix: TLS secret handling could leak memory.\n\n\nBug fix: with some combinations of Traffic Server and OpenSSL versions,\n    TLS certificates might not be loaded correctly.  Use the new\n    TS_SSL_CERT_HOOK hook to ensure this works properly in all cases.\n\n\nBug fix: An Endpoints with more than one port or address could be parsed\n    incorrectly or cause a crash.\n\n\n\n\n\n\n\n\n1.0.0-alpha4:\n\n\n\n\nDo not return a client error if the requested host or path was not\n  found, to allow use with other plugins like healthchecks.\n\n\n\n\n\n\n\n\n1.0.0-alpha3:\n\n\n\n\nGreatly improved unit test coverage.\n\n\nSeveral minor bugs fixed.\n\n\nSupport configuration via environment variables.\n\n\n\n\n\n\n\n\n1.0.0-alpha2: Implement IP address authentication.\n\n\n\n\n1.0.0-alpha1: Initial release.\n\n\n\n\nLicense and credits\n\n\nThis plugin was developed by Felicity Tarnell (ft@le-Fay.ORG) for\n\nTorchbox Ltd.\n.  Copyright (c) 2016-2017 Torchbox Ltd.\n\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely. This software is provided 'as-is', without any express or implied\nwarranty.\n\n\n\n\ncrypt_bf.c\n was written by Solar Designer, and is released into the public\ndomain.\n\n\ncrypt_des.c\n is copyright (c) 1989, 1993 The Regents of the University of\nCalifornia, based on code written by Tom Truscott.\n\n\ncrypt_md5.c\n was written by Poul-Henning Kamp, and is released under the\n\"beer-ware\" license.\n\n\ncrypt_sha256.c\n and \ncrypt_sha512.c\n were written by Ulrich Drepper, and are\nreleased into the public domain.\n\n\nstrmatch.c\n is copyright (c) 1989, 1993, 1994 The Regents of the University\nof California, based on code written by Guido van Rossum.\n\n\ncontrib/rax\n is Copyright (c) 2017, Salvatore Sanfilippo \n\n\ncontrib/brotli\n is Copyright 2013 Google Inc.\n\n\nbase64.c\n is copyright (c) 2011-2017 Felicity Tarnell.",
            "title": "Home"
        },
        {
            "location": "/#traffic-server-ingress-controller",
            "text": "WARNING: This is alpha code, do not use it in production.   (If you do,\nplease report bugs.)  Traffic Server  is a high-performance,\nextensible HTTP proxy server with a rich feature set, including TLS termination,\ncaching, and edge-side includes (ESI).  This plugin allows Traffic Server to\nact as an  Ingress  controller for Kubernetes  clusters, providing the reverse proxy that\nallows HTTP requests from the Internet to reach Kubernetes pods.  The controller is provided as C source code and as a pre-built Docker image.\nIf you want to add Kubernetes support to an existing instance of TS, you should\nbuild the plugin from source.  If you want to deploy TS inside a Kubernetes\ncluster, you can use the pre-built Docker image.",
            "title": "Traffic Server ingress controller"
        },
        {
            "location": "/#quick-start",
            "text": "To deploy the image on an existing Kubernetes 1.6 (or later) cluster:  $ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-rbac.yaml | kubectl apply -f -\n$ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-deployment.yaml | kubectl apply -f -  (If you're using 1.5 or earlier, you can still use  example-deployment.yaml ,\nbut if you need RBAC support you will need to convert  example-rbac.yaml  to use\nthe old alpha RBAC API.)  This will start two copies of Traffic Server, each with an emptyDir volume for\ncache storage, listening on node ports 30080 (http) and 30443 (https).   You can\nconfigure an external load balancer of some sort to route incoming traffic to\nthose ports, or use Kubernetes' keepalived-vip \nto manage a virtual IP address on your cluster.  For more detailed installation instructions, see the documentation for building from source  or  Deploying on Kubernetes .",
            "title": "Quick start"
        },
        {
            "location": "/#features",
            "text": "The controller provides the following features:   Full support for Ingress resources, including many annotations used by other\n  controller implementations;  HTTP/2, including server push;  WebSockets;  TLS termination, configured in the Ingress resource using Kubernetes Secrets;  Emulation of the nginx Ingress controller (for services that require it,\n  e.g. kube-lego);  Flexible HTTP caching, including:  Cache lifetime controlled by  Cache-Control  or  Expires  headers;  Manipulation of outgoing Cache-Control;  Removal from the cache of individual pages or all pages at once;  Alternatives (HTTP Vary);  Ignoring URL parameters and cookies which do not affect page content.    HTTP compression (gzip and Brotli);  Authorization using HTTP Basic authentication or client IP address;  A complete, configurable CORS implementation;  Proxying to external (non-Kubernetes) services using Ingress resources;  ESI (Edge-Side Includes).",
            "title": "Features"
        },
        {
            "location": "/#planned-features",
            "text": "A feature being listed here indicates we are interested in implementing it, but\nprovides no guarantee that it will be implemented within any particular time\nframe, or ever.  If you would like to see a particular feature supported, whether it's on this\nlist or not, please open a Github issue .   TLS client certificate authentication.  Client session affinity  Proxy protocol  Rate limiting  SSL passthrough  Global / default configuration  HSTS preload support (in any case, rewrite the HSTS support as it will be\n  removed from TS core in some later release)  Custom error bodies  Support  libslz  as an alternative to zlib.  Improve API watch support by first retrieving all objects, then watching with\n  resourceVersion.  Wildcard cache purging.",
            "title": "Planned features"
        },
        {
            "location": "/#release-history",
            "text": "1.0.0-alpha8 (unreleased):   Feature: HTTP/2 Server Push was implemented.     1.0.0-alpha7:   Improvement: The Traffic Server version in the Docker image has been\n    upgraded from 7.0.0 to 7.1.x (prerelease).  Improvement: The hash tree implementation has been replaced with a radix\n    tree, reducing memory use for small clusters and providing better (and\n    more predictable) performance for large clusters.  Bug fix: A synthetic response could cause a crash.  Bug fix: An incorrect Cookie header could be sent to the origin.  Bug fix: An incorrect Content-Encoding header could be sent to the client\n    if the client supported compression but the response object was not\n    compressed.     1.0.0-alpha6:   Incompatible change: The behaviour of the  app-root  annotation was\n    changed to match the behaviour of other Ingress controllers.  Incompatible change: Several annotations were moved from\n     ingress.torchbox.com  to  ingress.kubernetes.io  to improve\n     compatibility among Ingress controllers.  Feature: The  ingress.kubernetes.io/read-response-timeout  annotation\n    was implemented.  Feature: CORS annotations were implemented.  Feature: HTTP compression was implemented.  Feature: For Ingress resources with caching enabled, an  X-Cache-Status \n    header is returned in the response, indicating whether the request was\n    cached and the current cache generation.  Feature: The  cache-ignore-cookies  annotation was implemented.  Bug fix: With certain combinations of OpenSSL and Traffic Server versions,\n    a TLS request for an unknown host could hang indefinitely instead of\n    returning an error.     1.0.0-alpha5:   Incompatible change: The  ingress.torchbox.com/auth-address-list \n    annotation was renamed to  ingress.torchbox.com/whitelist-source-range ,\n    and is now comma-delimited, for compatibility with other Ingress\n    controllers.  Feature: Support Ingress classes.  Feature: The X-Forwarded-Proto header is now (optionally) sent to the\n    backend.  Feature: The  cache-whitelist-params  and  cache-ignore-params \n    annotations were implemented.  Feature: The  tls_verify  configuration option was added.  Improvement: The API server connection code was reimplemented using cURL,\n    making it more reliable and featureful.  Bug fix: TLS redirects with an empty URL path could crash.  Bug fix: TLS secret handling could leak memory.  Bug fix: with some combinations of Traffic Server and OpenSSL versions,\n    TLS certificates might not be loaded correctly.  Use the new\n    TS_SSL_CERT_HOOK hook to ensure this works properly in all cases.  Bug fix: An Endpoints with more than one port or address could be parsed\n    incorrectly or cause a crash.     1.0.0-alpha4:   Do not return a client error if the requested host or path was not\n  found, to allow use with other plugins like healthchecks.     1.0.0-alpha3:   Greatly improved unit test coverage.  Several minor bugs fixed.  Support configuration via environment variables.     1.0.0-alpha2: Implement IP address authentication.   1.0.0-alpha1: Initial release.",
            "title": "Release history"
        },
        {
            "location": "/#license-and-credits",
            "text": "This plugin was developed by Felicity Tarnell (ft@le-Fay.ORG) for Torchbox Ltd. .  Copyright (c) 2016-2017 Torchbox Ltd.  Permission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely. This software is provided 'as-is', without any express or implied\nwarranty.   crypt_bf.c  was written by Solar Designer, and is released into the public\ndomain.  crypt_des.c  is copyright (c) 1989, 1993 The Regents of the University of\nCalifornia, based on code written by Tom Truscott.  crypt_md5.c  was written by Poul-Henning Kamp, and is released under the\n\"beer-ware\" license.  crypt_sha256.c  and  crypt_sha512.c  were written by Ulrich Drepper, and are\nreleased into the public domain.  strmatch.c  is copyright (c) 1989, 1993, 1994 The Regents of the University\nof California, based on code written by Guido van Rossum.  contrib/rax  is Copyright (c) 2017, Salvatore Sanfilippo   contrib/brotli  is Copyright 2013 Google Inc.  base64.c  is copyright (c) 2011-2017 Felicity Tarnell.",
            "title": "License and credits"
        },
        {
            "location": "/source/",
            "text": "Installing the plugin from source\n\n\nIf you want to integrate Kubernetes with an existing Traffic Server installation,\nyou can build the plugin from source.  If you're planning to deploy the plugin\ninside a Kubernetes cluster, you should read \nUsing the Docker image\n\ninstead.\n\n\nRequirements\n\n\nThe following are required to build:\n\n\n\n\nTraffic Server 7.1 or later (including development headers).  Older versions\n  might work, but are not tested or supported.  In particular, TS 7.0 (the\n  latest released version) is currently not supported; we intend to address this\n  in a future release of the plugin.\n\n\nA working C99 compiler and \nmake\n utility.\n\n\njson-c library\n\n\ncURL library\n\n\nOpenSSL (or a compatible TLS library, e.g. LibreSSL)\n\n\n\n\nIf you want to run the unit tests, a C++11 compiler is required.  If you want to\nrun the end-to-end tests, a Linux/amd64 host is required (because those tests\nrequire running the Kubernetes API server).\n\n\nBuilding\n\n\nTo build and install the plugin:\n\n\n$ autoreconf -if            # only if building from a git checkout\n$ ./configure [--with-tsxs=/path/to/trafficserver/bin/tsxs]\n$ make\n$ make install\n\n\n\n\nThis will put \nkubernetes.so\n in your Traffic Server plugins directory.  Edit\n\nplugin.config\n to tell Traffic Server to load the plugin.\n\n\nTo run the unit tests:\n\n\n$ make test\n\n\n\n\nTo run the end-to-end tests:\n\n\n$ tests/e2erun.sh\n\n\n\n\nConfiguration\n\n\nIf Traffic Server is not running inside the cluster, you will need to provide a\n\nkubernetes.config\n configuration file.  See \nConfiguration\n for\ndetails.\n\n\nIf TS is running inside the cluster, it will pick up its service account details\nautomatically and the configuration file is not required, but you will need to\nensure it has access to the resources it needs to run.  If you're using RBAC\nfor authorization, see \nrbac.yaml\n for an example RBAC configuration.",
            "title": "Installing from source"
        },
        {
            "location": "/source/#installing-the-plugin-from-source",
            "text": "If you want to integrate Kubernetes with an existing Traffic Server installation,\nyou can build the plugin from source.  If you're planning to deploy the plugin\ninside a Kubernetes cluster, you should read  Using the Docker image \ninstead.",
            "title": "Installing the plugin from source"
        },
        {
            "location": "/source/#requirements",
            "text": "The following are required to build:   Traffic Server 7.1 or later (including development headers).  Older versions\n  might work, but are not tested or supported.  In particular, TS 7.0 (the\n  latest released version) is currently not supported; we intend to address this\n  in a future release of the plugin.  A working C99 compiler and  make  utility.  json-c library  cURL library  OpenSSL (or a compatible TLS library, e.g. LibreSSL)   If you want to run the unit tests, a C++11 compiler is required.  If you want to\nrun the end-to-end tests, a Linux/amd64 host is required (because those tests\nrequire running the Kubernetes API server).",
            "title": "Requirements"
        },
        {
            "location": "/source/#building",
            "text": "To build and install the plugin:  $ autoreconf -if            # only if building from a git checkout\n$ ./configure [--with-tsxs=/path/to/trafficserver/bin/tsxs]\n$ make\n$ make install  This will put  kubernetes.so  in your Traffic Server plugins directory.  Edit plugin.config  to tell Traffic Server to load the plugin.  To run the unit tests:  $ make test  To run the end-to-end tests:  $ tests/e2erun.sh",
            "title": "Building"
        },
        {
            "location": "/source/#configuration",
            "text": "If Traffic Server is not running inside the cluster, you will need to provide a kubernetes.config  configuration file.  See  Configuration  for\ndetails.  If TS is running inside the cluster, it will pick up its service account details\nautomatically and the configuration file is not required, but you will need to\nensure it has access to the resources it needs to run.  If you're using RBAC\nfor authorization, see  rbac.yaml  for an example RBAC configuration.",
            "title": "Configuration"
        },
        {
            "location": "/docker/",
            "text": "Using the Docker image on Kubernetes\n\n\nWe provide two examples Kubernetes deployments for the TS ingress controller:\n\n\n\n\nexample-daemonset.yaml\n uses a DaemonSet, with an example of using node\n  taints and affinity to run the controller only on master nodes, and exposes\n  TS using a hostPort;\n\n\nexample-deployment.yaml\n uses a Deployment, with a nodePort Service used to\n  expose TS.\n\n\n\n\nThese both use the Docker image \ndocker.io/torchbox/k8s-ts-ingress:v1.0.0-alpha7\n.\n\n\nYou will probably want to read and edit one of these files before using it.\n\n\nUnfortunately, there are many different ways to expose an Ingress controller on\nKubernetes, and we can't document every possible variation, so you will need to\ndecide what method is best for your cluster.\n\n\nRuntime configuration\n\n\nMost Traffic Server configuration (\nrecords.config\n entries) can be changed\nusing environment variables; see the\n\nTraffic Server Documentation\n.  For example, to make Traffic Server listen on port 7080 for HTTP requests,\nset \nPROXY_CONFIG_HTTP_SERVER_PORTS=7080\n.\n\n\nThe TS Docker image provides one additional environment variable:\n\n\n\n\nTS_CACHE_SIZE=nnn\n: Size of the on-disk cache file to create, in megabytes.\n\n\n\n\nCache storage\n\n\nThe example deployment resources use an \nemptyDir\n for cache storage.  This\nmeans the cache will persist across node reboots, but will we cleared if the\npod is move to a different node, or if it's upgraded (which deletes the old pod).\n\n\nThe cache file will be created automatically on startup if it doesn't exist.\n\n\nFor persistent cache storage, mount a volume on \n/var/lib/trafficserver\n. \nHowever, be aware that only one instance of TS can access the cache at once.  If\nyou are running multiple copies, you will need to create a separate PV for each\ninstance (perhaps by using a StatefulSet instead of a DaemonSet).",
            "title": "Using the Docker Image"
        },
        {
            "location": "/docker/#using-the-docker-image-on-kubernetes",
            "text": "We provide two examples Kubernetes deployments for the TS ingress controller:   example-daemonset.yaml  uses a DaemonSet, with an example of using node\n  taints and affinity to run the controller only on master nodes, and exposes\n  TS using a hostPort;  example-deployment.yaml  uses a Deployment, with a nodePort Service used to\n  expose TS.   These both use the Docker image  docker.io/torchbox/k8s-ts-ingress:v1.0.0-alpha7 .  You will probably want to read and edit one of these files before using it.  Unfortunately, there are many different ways to expose an Ingress controller on\nKubernetes, and we can't document every possible variation, so you will need to\ndecide what method is best for your cluster.",
            "title": "Using the Docker image on Kubernetes"
        },
        {
            "location": "/docker/#runtime-configuration",
            "text": "Most Traffic Server configuration ( records.config  entries) can be changed\nusing environment variables; see the Traffic Server Documentation .  For example, to make Traffic Server listen on port 7080 for HTTP requests,\nset  PROXY_CONFIG_HTTP_SERVER_PORTS=7080 .  The TS Docker image provides one additional environment variable:   TS_CACHE_SIZE=nnn : Size of the on-disk cache file to create, in megabytes.",
            "title": "Runtime configuration"
        },
        {
            "location": "/docker/#cache-storage",
            "text": "The example deployment resources use an  emptyDir  for cache storage.  This\nmeans the cache will persist across node reboots, but will we cleared if the\npod is move to a different node, or if it's upgraded (which deletes the old pod).  The cache file will be created automatically on startup if it doesn't exist.  For persistent cache storage, mount a volume on  /var/lib/trafficserver . \nHowever, be aware that only one instance of TS can access the cache at once.  If\nyou are running multiple copies, you will need to create a separate PV for each\ninstance (perhaps by using a StatefulSet instead of a DaemonSet).",
            "title": "Cache storage"
        },
        {
            "location": "/classes/",
            "text": "Using multiple Ingress controllers\n\n\nIf you want to deploy more than one Ingress controller inside a cluster (for\nexample, to test the TS Ingress controller before deploying it properly), you\nwill need to use Ingress classes to control which resources should be handled\nby which controller.\n\n\nThe Ingress class is set as an annotation on the resource:\n\n\nmetadata:\n  annotations:\n    kubernetes.io/ingress.class: \"trafficserver\"\n\n\n\n\nThe TS Ingress controller will handle any Ingress resource which does not have\nan Ingress class set, or where the Ingress class is set to \"trafficserver\".\n\n\nTo change the Ingress classes that TS will handle, set \ningress_classes\n in\n\nkubernetes.config\n (or the \n$TS_INGRESS_CLASSES\n environment variable) to a\nwhitespace-separate list of values, e.g. \n\"trafficserver ts-staging\"\n.  This\ncan be used to run multiple copies of the TS Ingress controller in one cluster.\nIf you do this, the \ntrafficserver\n class will not be handled unless you\nexplicitly include it in the list.\n\n\nFor more information, see\n\nUsing Multiple Ingress Controller\n\nin the Kubernetes documentation.",
            "title": "Using multiple Ingress controllers"
        },
        {
            "location": "/classes/#using-multiple-ingress-controllers",
            "text": "If you want to deploy more than one Ingress controller inside a cluster (for\nexample, to test the TS Ingress controller before deploying it properly), you\nwill need to use Ingress classes to control which resources should be handled\nby which controller.  The Ingress class is set as an annotation on the resource:  metadata:\n  annotations:\n    kubernetes.io/ingress.class: \"trafficserver\"  The TS Ingress controller will handle any Ingress resource which does not have\nan Ingress class set, or where the Ingress class is set to \"trafficserver\".  To change the Ingress classes that TS will handle, set  ingress_classes  in kubernetes.config  (or the  $TS_INGRESS_CLASSES  environment variable) to a\nwhitespace-separate list of values, e.g.  \"trafficserver ts-staging\" .  This\ncan be used to run multiple copies of the TS Ingress controller in one cluster.\nIf you do this, the  trafficserver  class will not be handled unless you\nexplicitly include it in the list.  For more information, see Using Multiple Ingress Controller \nin the Kubernetes documentation.",
            "title": "Using multiple Ingress controllers"
        },
        {
            "location": "/config/",
            "text": "Configuration\n\n\nThere are two ways to configure the controller: you can pass a configuration\nfile to the plugin in \nplugin.config\n, or you can set the configuration in the\nenvironment.  If a configuration option is set in both the configuration file\nand the environment, the value from the environment takes precedence.\n\n\nTo load a configuration file, pass its name as an argument to the plugin in\n\nplugin.config\n:\n\n\nkubernetes.so /path/to/kubernetes.config\n\n\n\n\nIf the configuration filename is a relative pathname, it will be loaded from\nTS's configuration directory (the place where \nrecords.config\n is located).\n\n\nIf you're deploying from the Docker image, using environment variables is the\nrecommended method; you would have to rebuild the Docker image to add a\nconfiguration file.\n\n\nKubernetes API server configuration\n\n\nIf TS is running inside the cluster, you do not need to configure the API\nserver connection details; they will be picked up automatically from the pod's\nservice account.  However, if you are running outside the cluster you need to\nspecify the API server URL and any credentials required to authenticate to it.\n\n\n\n\n\n\nserver: <url>\n: set the URL (http or https) of the API server the controller\n  should connect to.  (\n$TS_SERVER\n)\n\n\n\n\n\n\ncafile: <filename>\n: the filename of a PEM-encoded certificate file or\n  bundle that will be used to validate a TLS connection to the API server.\n  Ignored if the connection to the API server does not use TLS.  (\n$TS_CAFILE\n)\n\n\n\n\n\n\nverify_tls: <true|false>\n: whether to verify the API server's TLS certificate.\n  There should be no need to disable this.  (\n$TS_VERIFY_TLS\n)\n\n\n\n\n\n\ncertfile: <filename>\n: the filename of a PEM-encoded TLS certificate that\n  will be used to authenticate to the API server.  If set, you must supply a TLS\n  key as well. (\n$TS_CERTFILE\n)\n\n\n\n\n\n\nkeyfile: <filename>\n: the filename of a PEM-encoded TLS key that will be used\n  to authenticate to the API server.  If set, you must supply a TLS certificate\n  as well.  (\n$TS_KEYFILE\n)\n\n\n\n\n\n\ntoken: <token>\n: an authentication Bearer token that will be used to\n  authenticate to the API server, if using token authentication.  (\n$TS_TOKEN\n)\n\n\n\n\n\n\nGlobal configuration\n\n\n\n\n\n\ningress_classes: <class> [<class> ...]\n: a list of Ingress classes that the\n  controller will process.  See \nUsing multiple Ingress classes\n for\n  more information on this option. Default: \ntrafficserver\n.\n  (\n$TS_INGRESS_CLASSES\n)\n\n\n\n\n\n\ntls: <true|false>\n: whether to handle TLS certificates.  If set to \nfalse\n,\n  you will need to load TLS certificates by some other mechanism.  Default:\n  \ntrue\n.  (\n$TS_TLS\n)\n\n\n\n\n\n\nremap: <true|false>\n: whether to handle host and path remapping.  If set to\n  \nfalse\n, only TLS certificate loading will be done.  Default: \ntrue\n.\n  (\n$TS_REMAP\n)\n\n\n\n\n\n\nx_forwarded_proto: <true|false>\n: whether to send an \nX-Forwarded-Proto\n\n  header to backends, containing the client protocol (\nhttp\n or \nhttps\n).\n  Default: \ntrue\n.  (\n$TS_X_FORWARDED_PROTO\n)",
            "title": "Configuration"
        },
        {
            "location": "/config/#configuration",
            "text": "There are two ways to configure the controller: you can pass a configuration\nfile to the plugin in  plugin.config , or you can set the configuration in the\nenvironment.  If a configuration option is set in both the configuration file\nand the environment, the value from the environment takes precedence.  To load a configuration file, pass its name as an argument to the plugin in plugin.config :  kubernetes.so /path/to/kubernetes.config  If the configuration filename is a relative pathname, it will be loaded from\nTS's configuration directory (the place where  records.config  is located).  If you're deploying from the Docker image, using environment variables is the\nrecommended method; you would have to rebuild the Docker image to add a\nconfiguration file.",
            "title": "Configuration"
        },
        {
            "location": "/config/#kubernetes-api-server-configuration",
            "text": "If TS is running inside the cluster, you do not need to configure the API\nserver connection details; they will be picked up automatically from the pod's\nservice account.  However, if you are running outside the cluster you need to\nspecify the API server URL and any credentials required to authenticate to it.    server: <url> : set the URL (http or https) of the API server the controller\n  should connect to.  ( $TS_SERVER )    cafile: <filename> : the filename of a PEM-encoded certificate file or\n  bundle that will be used to validate a TLS connection to the API server.\n  Ignored if the connection to the API server does not use TLS.  ( $TS_CAFILE )    verify_tls: <true|false> : whether to verify the API server's TLS certificate.\n  There should be no need to disable this.  ( $TS_VERIFY_TLS )    certfile: <filename> : the filename of a PEM-encoded TLS certificate that\n  will be used to authenticate to the API server.  If set, you must supply a TLS\n  key as well. ( $TS_CERTFILE )    keyfile: <filename> : the filename of a PEM-encoded TLS key that will be used\n  to authenticate to the API server.  If set, you must supply a TLS certificate\n  as well.  ( $TS_KEYFILE )    token: <token> : an authentication Bearer token that will be used to\n  authenticate to the API server, if using token authentication.  ( $TS_TOKEN )",
            "title": "Kubernetes API server configuration"
        },
        {
            "location": "/config/#global-configuration",
            "text": "ingress_classes: <class> [<class> ...] : a list of Ingress classes that the\n  controller will process.  See  Using multiple Ingress classes  for\n  more information on this option. Default:  trafficserver .\n  ( $TS_INGRESS_CLASSES )    tls: <true|false> : whether to handle TLS certificates.  If set to  false ,\n  you will need to load TLS certificates by some other mechanism.  Default:\n   true .  ( $TS_TLS )    remap: <true|false> : whether to handle host and path remapping.  If set to\n   false , only TLS certificate loading will be done.  Default:  true .\n  ( $TS_REMAP )    x_forwarded_proto: <true|false> : whether to send an  X-Forwarded-Proto \n  header to backends, containing the client protocol ( http  or  https ).\n  Default:  true .  ( $TS_X_FORWARDED_PROTO )",
            "title": "Global configuration"
        },
        {
            "location": "/annotations/",
            "text": "Ingress annotations\n\n\nThe behaviour of an Ingress can be configured by setting annotations on the\nIngress resource, e.g.:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/rewrite-target: '/myapp'\n\n\n\n\nAnnotations whose names with \ningress.kubernetes.io\n are standard annotations\nsupported by most Ingress controllers; those beginning with\n\ningress.kubernetes.io\n are specific to the Traffic Server Ingress controller.\n\n\n\n\n\n\ningress.kubernetes.io/rewrite-target\n: if set to a string, the portion of the\n  request path matched by the Ingress \npath\n attribute will be replaced with\n  this string.  This has no effect on an Ingress without a \npath\n set.\n\n\n\n\n\n\ningress.kubernetes.io/app-root\n: if set to a path, requests for \n/\n will be\n  redirected to this path.  This can be used for applications which sit in a\n  subdirectory rather than at the root.\n\n\n\n\n\n\ningress.kubernetes.io/follow-redirects\n: if \n\"true\"\n, Traffic Server will\n  follow 3xx redirect responses and serve the final response to the client.\n  If the redirect destination is cached, it will be cached with the cache key\n  of the original request.  Redirects will only be followed to other Ingress\n  resources, not to arbitrary destinations (but see below about proxying to\n  external resources).\n\n\n\n\n\n\ningress.kubernetes.io/preserve-host\n: if \n\"false\"\n, set the \nHost\n header\n  in the request to the backend name (e.g., the pod name), instead of the\n  original request host.\n\n\n\n\n\n\n`ingress.kubernetes.io/read-response-timeout\": set the time in seconds that\n  TS will wait for for the response from the origin.  If this timeout is\n  exceeded, an HTTP 504 error will be returned to the client.",
            "title": "Annotations"
        },
        {
            "location": "/annotations/#ingress-annotations",
            "text": "The behaviour of an Ingress can be configured by setting annotations on the\nIngress resource, e.g.:  metadata:\n  annotations:\n    ingress.kubernetes.io/rewrite-target: '/myapp'  Annotations whose names with  ingress.kubernetes.io  are standard annotations\nsupported by most Ingress controllers; those beginning with ingress.kubernetes.io  are specific to the Traffic Server Ingress controller.    ingress.kubernetes.io/rewrite-target : if set to a string, the portion of the\n  request path matched by the Ingress  path  attribute will be replaced with\n  this string.  This has no effect on an Ingress without a  path  set.    ingress.kubernetes.io/app-root : if set to a path, requests for  /  will be\n  redirected to this path.  This can be used for applications which sit in a\n  subdirectory rather than at the root.    ingress.kubernetes.io/follow-redirects : if  \"true\" , Traffic Server will\n  follow 3xx redirect responses and serve the final response to the client.\n  If the redirect destination is cached, it will be cached with the cache key\n  of the original request.  Redirects will only be followed to other Ingress\n  resources, not to arbitrary destinations (but see below about proxying to\n  external resources).    ingress.kubernetes.io/preserve-host : if  \"false\" , set the  Host  header\n  in the request to the backend name (e.g., the pod name), instead of the\n  original request host.    `ingress.kubernetes.io/read-response-timeout\": set the time in seconds that\n  TS will wait for for the response from the origin.  If this timeout is\n  exceeded, an HTTP 504 error will be returned to the client.",
            "title": "Ingress annotations"
        },
        {
            "location": "/caching/",
            "text": "Using HTTP caching\n\n\nTraffic Server can cache HTTP and HTTPS responses from an application to improve\npage load speed.  On a site which serves a large amount of infrequently\nchanging pages to anonymous users, caching can provide a significant improvement\nto both performance and page load times.  It's not uncommon to see caching\nimprove a site's capacity from tens of requests per second to tens of thousands\nof requests per second, without using any additional resources (except for\nbandwidth, of course).\n\n\nConfiguring caching\n\n\nCaching is enabled on Ingress resources by default.  To indicate that a response\nis to be cached, your application should send a \nCache-Control\n header field in\nthe response:\n\n\nHTTP/1.1 200 OK\nCache-Control: public, max-age=3600\nContent-Type: text/html; charset=UTF-8\n...\n\n\n\n\nLike most HTTP header fields, this is a comma-separated list of values.  \npublic\n\nindicates that the page content does not contain private data (meaning it should\nbe cached by multi-user proxies like Traffic Server), and \nmax-age\n indicates how\nlong it should be cached for; in this case, 3600 seconds or one hour.\n\n\nAs an alternative to \nCache-Control\n, your application can send an \nExpires\n\nheader field containing a timestamp; the page will be cached until the expiry\ntime is reached.  \nExpires\n is not recommended for new applications, since\n\nCache-Control\n is more flexible and has better defined semantics.\n\n\nDisabling caching\n\n\nIf you want to prevent certain pages from being cached, you can indicate this\nusing \nCache-Control\n:\n\n\nHTTP/1.1 200 OK\nCache-Control: no-cache, no-store\n\n\n\n\nYou should generally do this for any personalised pages, e.g. pages served to\nlogged-in users, or pages containing a \nSet-Cookie\n header field.  By default,\nTS will not use the cache for requests containing a \nCookie\n header field or\ncache responses containing a \nSet-Cookie\n field, but it's better to be explicit.\n\n\nTo disable caching entirely on an Ingress, even if it sends \nCache-Control\n or\n\nExpires\n header fields, use the \ningress.kubernetes.io/cache-enable\n annotation:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"\n\n\n\n\nIf only some paths should have caching disabled, you can create another Ingress\nresource for that particular path:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"\n  name: echoheaders\nspec:\n  rules:\n  - host: www.mysite.path\n    http:\n      paths:\n      - path: /admin\n        backend:\n          serviceName: myapp\n          servicePort: http\n\n\n\n\nControlling downstream caching\n\n\nWhen a page is cached in Traffic Server, an application can easily\n\nremove the page from the cache\n when it changes.\nThis allows the application to set a long cache lifetime and rely on cache\npurging to keep content up to date.\n\n\nHowever, the application cannot purge content from clients or downstream caches,\nsuch as ISP or organisational proxies.  This means if your \nCache-Control\n\nheader indicates the response should be cached for 30 days, the client may never\nfetch fresh content until 30 days have passed, even if the document is updated\nbefore then in the TS cache.\n\n\nIn some cases, like static assets which have cache-aware URLs, the content for a\nparticular URL will never change, and this behaviour is desirable.  However, it's\ngenerally \nnot\n desirable for HTML, where the document content often changes\nwithout the URL changing.\n\n\nTo prevent clients or downstream proxies from caching responses, you can set the\n\nX-Next-Hop-Cache-Control\n header field in the response.  If present, TS will\nuse this value to replace the \nCache-Control\n header field, but still use the\noriginal \nCache-Control\n for its own caching.\n\n\nA suitable value for HTML content using a 30-day cache lifetime would be:\n\n\nX-Next-Hop-Cache-Control: no-cache, max-age=2592000\n\n\n\n\nThis means that clients can still cache the document for up to 30 days, but the\n\nno-cache\n directive requires the document to be revalidated with the origin\nserver before it's used.  Since the document should be in the TS cache,\nvalidation should be quick and won't require the document to be re-sent unless\nit's changed.\n\n\nCaching and URL parameters\n\n\nWhen a page is cached, its URL parameters are stored in the cache to ensure that\na request with different URL parameters returns the correct content.  For\nexample, the URL:\n\n\nhttp://www.mysite.com/listings/?page=1\n\n\n\n\nwill be cached differently from the URL:\n\n\nhttp://www.mysite.com/listings/?page=2\n\n\n\n\nUsually this is what you want and no additional configuration is required.\nHowever, sometimes clients may request pages with additional URL parameters\nwhich do not affect page content.  A good example of this is marketing tracking\nparameters like \nutm_medium\n which are used by JavaScript on the page to\nidentify traffic sources, but do not affect the page content at all.  Because\nthese URL parameters do not affect page content, they should not be considered\nwhen caching.  (The JavaScript tracking code will run anyway, so no data is\nlost.)\n\n\nThere are two approaches to configuring this: either you can set a list of URL\nparameters which should be ignored when caching (which is the safest method),\nor you can set a whitelist of parameters, where any parameters not in the\nlist will be ignored.\n\n\nTo exclude a set of parameters from caching, set the\n\ningress.kubernetes.io/cache-ignore-query-params\n annotation on the Ingress:\n\n\n    ingress.kubernetes.io/cache-ignore-query-params: \"utm_* source_id\"\n\n\n\n\nThe value should be a list of UNIX globs (\n*\n, \n?\n and \n[...]\n are supported);\nany matching query parameters will be ignored for caching.\n\n\nTo set a whitelist of URL parameters, set the\n\ningress.kubernetes.io/cache-whitelist-query-params\n annotation:\n\n\n    ingress.kubernetes.io/cache-whitelist-query-params: \"page view include_id_*\"\n\n\n\n\nThe format is the same as \ncache-ignore-query-params\n, but the meaning is\nreversed: any URL parameter not matched will be ignored.\n\n\nWhen using either of these annotations, you probably also want to set\n\ningress.kubernetes.io/cache-sort-query-params: \"true\"\n, which will cause the\nURL parameters to be lexically sorted.  This means that a request for\n\n/?a=1&b=2\n can be served a cached response for\n/?b=2&a=1\n, improving cache hit\nrate across clients.\n\n\nThese annotations also change the query string sent to the application.  This is\nto ensure the application doesn't accidentally vary the page content based on a\nquery parameter that has been ignored for caching.\n\n\nCaching and cookies\n\n\nUsually, TS will not cache a response or serve a request from the cache if\neither of the following are true:\n\n\n\n\nThe request has a \nCookie\n header field\n\n\nThe response has a \nSet-Cookie\n header field\n\n\n\n\nThis is true even if the response includes an explicit \nCache-Control\n, and is\nintended to avoid accidental leakage of private data due to misconfiguration.\n\n\nHowever, in some cases your users may have cookies set that do not affect page\ncontent.  This is common with tracking cookies for page analytics tools; Google\nAnalytics, for example, sets several cookies with names like \n__utma\n, which are\nonly ever referenced from JavaScript and do not affect page content.\n\n\nTo allow caching to work even with these cookies set, use the\n\ningress.kubernetes.io/cache-ignore-cookies\n annotation:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/cache-ignore-cookies: \"utm_* has_js\"\n\n\n\n\nThe annotation value should be a space-delimited list of UNIX globs; any cookie\nin the request \nCookie:\n header field which matches one of the globs will be\nremoved.  If there are no cookies left, then the entire \nCookie\n header field\nwill be removed from the request; the request can then be served from the cache,\nor its response can be stored in the cache.\n\n\nIf any cookies remain after processing, caching will be bypassed as normal.\n\n\nRemoving pages from the cache\n\n\nRemoving individual URLs\n\n\nYou can purge individual URLs from the cache by sending an HTTP \nPURGE\n request\nto Traffic Server.  To make this easy to do from pods, create a Service for the\nTS pod.  The PURGE request should look like this:\n\n\nPURGE http://www.mysite.com/mypage.html HTTP/1.0\n\n\n\n\nUnfortunately, this doesn't work very well when multiple copies of TS are\nrunning, since there's no simple way for an application to retrieve the list of\nTS instances.  We plan to address this in a future release.\n\n\nClearing the entire cache\n\n\nOccasionally, you might want to clear the cache for an entire domain, for\nexample if some boilerplate HTML has changed that affects all pages.  To do this,\nset the \ningress.kubernetes.io/cache-generation\n annotation to a non-zero\ninteger.  This changes the cache generation for the Ingress; any objects cached\nwith a different generation are no longer visible, and have been effectively\nremoved from the cache.  Typically the cache generation would be set to the\ncurrent UNIX timestamp, although any non-zero integer will work.\n\n\nCaching and static assets\n\n\nStatic assets can be purged from the cache when they change in the same way as\nHTML content.  However, this is quite inefficient: whenever the application is\nredeployed and static assets have changed, either the entire cache needs to be\npurged, or the individual URLs of each asset need to be purged.  Even then, this\nwill not purge content from downstream caches, meaning some users may not see\nyour updates.  While you could\n\nprevent clients from caching static assets\n,\nthis has a deleterious effect on performance.\n\n\nInstead, your application should change the URL of the assets when their\ncontent changes.  There are three common ways to do this:\n\n\n\n\nDefine a global \"style version\" in the application, and append this to the\n  URL as a query parameter: \n/css/main.css?42\n;\n\n\nCheck the timestamp of each asset, and append it to the URL, again as a\n  query parameter: \n/css/main.css?1496405714\n;\n\n\nCalculate the hash of the content of each asset, and include this as either\n  a part of the filename or a query parameter: \n/css/main.abcd1234.css\n or\n  \n/css/main.css?abcd1234\n.\n\n\n\n\nBecause the URL of the asset now changes when its content changes, clients will\nautomatically fetch the correct version of the asset, without having to clear\nanything from the cache (except the HTML, of course).  In addition, the assets\ncan be cached by clients or downstream proxies without the risk that out-of-date\ncached content will be used.\n\n\nThis is an extremely common pattern for caching static assets, so support is\navailable for doing it automatically in most web application frameworks.\n\n\nX-Cache-Status\n header\n\n\nWhen an Ingress has caching enable, TS will include an \nX-Cache-Status\n header\nin the HTTP response, which looks like this:\n\n\nX-Cache-Status: hit-fresh (1496232521)\n\n\n\n\nThe number in brackets is the current cache generation configured on the Ingress.\nThe first word is the cache lookup status, which can be:\n\n\n\n\nmiss\n: the document was not found in the cache, and TS went to the origin to\n  fetch it.\n\n\nhit-fresh\n: a valid copy of the document was found in the cache, and TS\n  served this copy without going to the origin.\n\n\nhit-stale\n: a stale copy of the document was found in the cache (e.g., it\n  had exceeded its \nmax-age\n), and TS went to the origin to revalidate the\n  document.  The document may still have been served from the cache if the\n  origin returned HTTP 304 (Not modified).\n\n\nskipped\n: TS did not do a cache lookup for the document.  This status is most\n  common with internally-generated responses, such as errors and redirects.",
            "title": "Caching"
        },
        {
            "location": "/caching/#using-http-caching",
            "text": "Traffic Server can cache HTTP and HTTPS responses from an application to improve\npage load speed.  On a site which serves a large amount of infrequently\nchanging pages to anonymous users, caching can provide a significant improvement\nto both performance and page load times.  It's not uncommon to see caching\nimprove a site's capacity from tens of requests per second to tens of thousands\nof requests per second, without using any additional resources (except for\nbandwidth, of course).",
            "title": "Using HTTP caching"
        },
        {
            "location": "/caching/#configuring-caching",
            "text": "Caching is enabled on Ingress resources by default.  To indicate that a response\nis to be cached, your application should send a  Cache-Control  header field in\nthe response:  HTTP/1.1 200 OK\nCache-Control: public, max-age=3600\nContent-Type: text/html; charset=UTF-8\n...  Like most HTTP header fields, this is a comma-separated list of values.   public \nindicates that the page content does not contain private data (meaning it should\nbe cached by multi-user proxies like Traffic Server), and  max-age  indicates how\nlong it should be cached for; in this case, 3600 seconds or one hour.  As an alternative to  Cache-Control , your application can send an  Expires \nheader field containing a timestamp; the page will be cached until the expiry\ntime is reached.   Expires  is not recommended for new applications, since Cache-Control  is more flexible and has better defined semantics.",
            "title": "Configuring caching"
        },
        {
            "location": "/caching/#disabling-caching",
            "text": "If you want to prevent certain pages from being cached, you can indicate this\nusing  Cache-Control :  HTTP/1.1 200 OK\nCache-Control: no-cache, no-store  You should generally do this for any personalised pages, e.g. pages served to\nlogged-in users, or pages containing a  Set-Cookie  header field.  By default,\nTS will not use the cache for requests containing a  Cookie  header field or\ncache responses containing a  Set-Cookie  field, but it's better to be explicit.  To disable caching entirely on an Ingress, even if it sends  Cache-Control  or Expires  header fields, use the  ingress.kubernetes.io/cache-enable  annotation:  metadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"  If only some paths should have caching disabled, you can create another Ingress\nresource for that particular path:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"\n  name: echoheaders\nspec:\n  rules:\n  - host: www.mysite.path\n    http:\n      paths:\n      - path: /admin\n        backend:\n          serviceName: myapp\n          servicePort: http",
            "title": "Disabling caching"
        },
        {
            "location": "/caching/#controlling-downstream-caching",
            "text": "When a page is cached in Traffic Server, an application can easily remove the page from the cache  when it changes.\nThis allows the application to set a long cache lifetime and rely on cache\npurging to keep content up to date.  However, the application cannot purge content from clients or downstream caches,\nsuch as ISP or organisational proxies.  This means if your  Cache-Control \nheader indicates the response should be cached for 30 days, the client may never\nfetch fresh content until 30 days have passed, even if the document is updated\nbefore then in the TS cache.  In some cases, like static assets which have cache-aware URLs, the content for a\nparticular URL will never change, and this behaviour is desirable.  However, it's\ngenerally  not  desirable for HTML, where the document content often changes\nwithout the URL changing.  To prevent clients or downstream proxies from caching responses, you can set the X-Next-Hop-Cache-Control  header field in the response.  If present, TS will\nuse this value to replace the  Cache-Control  header field, but still use the\noriginal  Cache-Control  for its own caching.  A suitable value for HTML content using a 30-day cache lifetime would be:  X-Next-Hop-Cache-Control: no-cache, max-age=2592000  This means that clients can still cache the document for up to 30 days, but the no-cache  directive requires the document to be revalidated with the origin\nserver before it's used.  Since the document should be in the TS cache,\nvalidation should be quick and won't require the document to be re-sent unless\nit's changed.",
            "title": "Controlling downstream caching"
        },
        {
            "location": "/caching/#caching-and-url-parameters",
            "text": "When a page is cached, its URL parameters are stored in the cache to ensure that\na request with different URL parameters returns the correct content.  For\nexample, the URL:  http://www.mysite.com/listings/?page=1  will be cached differently from the URL:  http://www.mysite.com/listings/?page=2  Usually this is what you want and no additional configuration is required.\nHowever, sometimes clients may request pages with additional URL parameters\nwhich do not affect page content.  A good example of this is marketing tracking\nparameters like  utm_medium  which are used by JavaScript on the page to\nidentify traffic sources, but do not affect the page content at all.  Because\nthese URL parameters do not affect page content, they should not be considered\nwhen caching.  (The JavaScript tracking code will run anyway, so no data is\nlost.)  There are two approaches to configuring this: either you can set a list of URL\nparameters which should be ignored when caching (which is the safest method),\nor you can set a whitelist of parameters, where any parameters not in the\nlist will be ignored.  To exclude a set of parameters from caching, set the ingress.kubernetes.io/cache-ignore-query-params  annotation on the Ingress:      ingress.kubernetes.io/cache-ignore-query-params: \"utm_* source_id\"  The value should be a list of UNIX globs ( * ,  ?  and  [...]  are supported);\nany matching query parameters will be ignored for caching.  To set a whitelist of URL parameters, set the ingress.kubernetes.io/cache-whitelist-query-params  annotation:      ingress.kubernetes.io/cache-whitelist-query-params: \"page view include_id_*\"  The format is the same as  cache-ignore-query-params , but the meaning is\nreversed: any URL parameter not matched will be ignored.  When using either of these annotations, you probably also want to set ingress.kubernetes.io/cache-sort-query-params: \"true\" , which will cause the\nURL parameters to be lexically sorted.  This means that a request for /?a=1&b=2  can be served a cached response for /?b=2&a=1 , improving cache hit\nrate across clients.  These annotations also change the query string sent to the application.  This is\nto ensure the application doesn't accidentally vary the page content based on a\nquery parameter that has been ignored for caching.",
            "title": "Caching and URL parameters"
        },
        {
            "location": "/caching/#caching-and-cookies",
            "text": "Usually, TS will not cache a response or serve a request from the cache if\neither of the following are true:   The request has a  Cookie  header field  The response has a  Set-Cookie  header field   This is true even if the response includes an explicit  Cache-Control , and is\nintended to avoid accidental leakage of private data due to misconfiguration.  However, in some cases your users may have cookies set that do not affect page\ncontent.  This is common with tracking cookies for page analytics tools; Google\nAnalytics, for example, sets several cookies with names like  __utma , which are\nonly ever referenced from JavaScript and do not affect page content.  To allow caching to work even with these cookies set, use the ingress.kubernetes.io/cache-ignore-cookies  annotation:  metadata:\n  annotations:\n    ingress.kubernetes.io/cache-ignore-cookies: \"utm_* has_js\"  The annotation value should be a space-delimited list of UNIX globs; any cookie\nin the request  Cookie:  header field which matches one of the globs will be\nremoved.  If there are no cookies left, then the entire  Cookie  header field\nwill be removed from the request; the request can then be served from the cache,\nor its response can be stored in the cache.  If any cookies remain after processing, caching will be bypassed as normal.",
            "title": "Caching and cookies"
        },
        {
            "location": "/caching/#removing-pages-from-the-cache",
            "text": "",
            "title": "Removing pages from the cache"
        },
        {
            "location": "/caching/#removing-individual-urls",
            "text": "You can purge individual URLs from the cache by sending an HTTP  PURGE  request\nto Traffic Server.  To make this easy to do from pods, create a Service for the\nTS pod.  The PURGE request should look like this:  PURGE http://www.mysite.com/mypage.html HTTP/1.0  Unfortunately, this doesn't work very well when multiple copies of TS are\nrunning, since there's no simple way for an application to retrieve the list of\nTS instances.  We plan to address this in a future release.",
            "title": "Removing individual URLs"
        },
        {
            "location": "/caching/#clearing-the-entire-cache",
            "text": "Occasionally, you might want to clear the cache for an entire domain, for\nexample if some boilerplate HTML has changed that affects all pages.  To do this,\nset the  ingress.kubernetes.io/cache-generation  annotation to a non-zero\ninteger.  This changes the cache generation for the Ingress; any objects cached\nwith a different generation are no longer visible, and have been effectively\nremoved from the cache.  Typically the cache generation would be set to the\ncurrent UNIX timestamp, although any non-zero integer will work.",
            "title": "Clearing the entire cache"
        },
        {
            "location": "/caching/#caching-and-static-assets",
            "text": "Static assets can be purged from the cache when they change in the same way as\nHTML content.  However, this is quite inefficient: whenever the application is\nredeployed and static assets have changed, either the entire cache needs to be\npurged, or the individual URLs of each asset need to be purged.  Even then, this\nwill not purge content from downstream caches, meaning some users may not see\nyour updates.  While you could prevent clients from caching static assets ,\nthis has a deleterious effect on performance.  Instead, your application should change the URL of the assets when their\ncontent changes.  There are three common ways to do this:   Define a global \"style version\" in the application, and append this to the\n  URL as a query parameter:  /css/main.css?42 ;  Check the timestamp of each asset, and append it to the URL, again as a\n  query parameter:  /css/main.css?1496405714 ;  Calculate the hash of the content of each asset, and include this as either\n  a part of the filename or a query parameter:  /css/main.abcd1234.css  or\n   /css/main.css?abcd1234 .   Because the URL of the asset now changes when its content changes, clients will\nautomatically fetch the correct version of the asset, without having to clear\nanything from the cache (except the HTML, of course).  In addition, the assets\ncan be cached by clients or downstream proxies without the risk that out-of-date\ncached content will be used.  This is an extremely common pattern for caching static assets, so support is\navailable for doing it automatically in most web application frameworks.",
            "title": "Caching and static assets"
        },
        {
            "location": "/caching/#x-cache-status-header",
            "text": "When an Ingress has caching enable, TS will include an  X-Cache-Status  header\nin the HTTP response, which looks like this:  X-Cache-Status: hit-fresh (1496232521)  The number in brackets is the current cache generation configured on the Ingress.\nThe first word is the cache lookup status, which can be:   miss : the document was not found in the cache, and TS went to the origin to\n  fetch it.  hit-fresh : a valid copy of the document was found in the cache, and TS\n  served this copy without going to the origin.  hit-stale : a stale copy of the document was found in the cache (e.g., it\n  had exceeded its  max-age ), and TS went to the origin to revalidate the\n  document.  The document may still have been served from the cache if the\n  origin returned HTTP 304 (Not modified).  skipped : TS did not do a cache lookup for the document.  This status is most\n  common with internally-generated responses, such as errors and redirects.",
            "title": "X-Cache-Status header"
        },
        {
            "location": "/auth/",
            "text": "Authentication\n\n\nAuthentication restricts who can request a particular page.  Authenticatian can\nbe done using HTTP basic authentication, where the client sends a username and\npassword in the request; by IP address, where only certain IP addresses are\npermitted to request the content; or by a combination of both.\n\n\nPassword authentication\n\n\nTo enable password authentication, set the \ningress.kubernetes.io/auth-type\n\nannotation on the Ingress to \nbasic\n, and \ningress.kubernetes.io/auth-secret\n\nto the name of a secret which contains an htpasswd file as the \nauth\n key:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/auth-type: basic\n    ingress.kubernetes.io/auth-secret: mysecret\n\n\n\n\nYou can create the necessary secret from an existing htpasswd file with \nkubectl\n:\n\n\n$ kubectl create secret generic mysecret --from-file=auth=my-htpasswd\n\n\n\n\nOptionally, set \ningress.kubernetes.io/auth-realm\n to the basic authentication\nrealm, which is displayed in the password prompt by most browsers.\n\n\nMost common password hash schemes are supported, including DES, MD5 (\n$1$\n and\n\n$apr1$\n), bcrypt (\n$2[abxy]$\n), SHA-256 (\n$5$\n) and SHA-512 (\n$6$\n), and four\nRFC2307-style hashes: \n{PLAIN}\n, \n{SHA}\n, \n{SSHA}\n and \n{CRYPT}\n (the first\nthree of which are also supported by nginx).\n\n\nSecurity-wise, although the MD5 schemes are extremely weak as password hashes,\nthey are probably fine for any situation where htpasswd-based authentication is\nin use.  The primary security improvement in newer algorithms (e.g. bcrypt and\nSHA-2) is they are slower, which increases the time required to perform an\noffline brute force attack; however, this also increases the time required to\n\ncheck\n the password, which leads to unacceptable delays on typical HTML page\nloads.\n\n\nFor example, if you use a bcrypt configuration that takes 200ms to check one\nhash, and you load an HTML page with 20 assets, then you will spend 4 seconds\ndoing nothing but waiting for authentication.  If multiple users are loading\npages at the same time, then things will be even slower once you run out of\nCPUs.\n\n\nIf you need stronger password security than MD5, you should stop using HTTP\nbasic authentication and use another authentication method (like Cookie-based\nauthentication) instead.\n\n\nIP address authentication\n\n\nTo enable IP authentication, set the\n\ningress.kubernetes.io/whitelist-source-range\n annotation to a comma-delimited\nlist of IP addresses or networks, for example \n\"127.0.0.0/8,::1/128\"\n.\n\n\nWhen both IP-based and password-authentication are configured on the same\ningress, you can set the \ningress.kubernetes.io/auth-satisfy\n annotation to\neither \nany\n or \nall\n:\n\n\n\n\n\n\nany\n will permit the request if either the IP is present in\n  \nwhitelist-source-range\n or if the client provides valid basic authentication;\n  otherwise the request will be denied with HTTP 401 Unauthorized.\n\n\n\n\n\n\nall\n will permit the request if the client IP is present in\n  \nwhitelist-source-range\n \nand\n the client also provides valid basic\n  authentication.  If the client IP address is not in the address list, the\n  request will be denied with HTTP 403 Forbidden.  If the IP address is present\n  but the request did not contain valid basic authentication, the request will\n  be denied with HTTP 401 Unauthorized.\n\n\n\n\n\n\nTo prevent accidental misconfiguration, the default value is \nall\n.\n\n\nImportant\n: IP address authentication requires that Traffic Server knows the\noriginal IP address of the client making the request.  If TS is serving requests\ndirectly, or sits behind a transparent load balancer that preserves the client\nIP address (such as an Azure service, a GCE network load balancer, or Linux LVS\nin some configurations), then this will be the case; otherwise, it will see all\nrequests as coming from the load balancer's internal IP address, and\nauthentication will not be effective.  We plan to address this limitation in a\nfuture release, using either the \nX-Forwarded-For\n header field, or the\nso-called Proxy Protocol.\n\n\nScalability note: The IP list is implemented as a simple linked list, rather\nthan a more efficient data structure such as a radix tree.  This means that the\nlookup time, and consequently the overall request time, will increase linearly\nas the number of entries in the list increases.\n\n\nThis decision was made because a linked list is a simpler data structure, and\ntherefore performs better with a small number of entries even though performance\nis worse with a larger list.  This trade-off will only become noticeable if you\nhave hundreds or thousands of entries in the address list, which is very\nunlikely in real-world deployments.  (For one thing, it would be extremely\ncumbersome to manage such a large list as an annotation.)\n\n\nIf you require support for such a large number of addresses in a single Ingress,\nplease let us know via a Github issue.",
            "title": "Authentication"
        },
        {
            "location": "/auth/#authentication",
            "text": "Authentication restricts who can request a particular page.  Authenticatian can\nbe done using HTTP basic authentication, where the client sends a username and\npassword in the request; by IP address, where only certain IP addresses are\npermitted to request the content; or by a combination of both.",
            "title": "Authentication"
        },
        {
            "location": "/auth/#password-authentication",
            "text": "To enable password authentication, set the  ingress.kubernetes.io/auth-type \nannotation on the Ingress to  basic , and  ingress.kubernetes.io/auth-secret \nto the name of a secret which contains an htpasswd file as the  auth  key:  metadata:\n  annotations:\n    ingress.kubernetes.io/auth-type: basic\n    ingress.kubernetes.io/auth-secret: mysecret  You can create the necessary secret from an existing htpasswd file with  kubectl :  $ kubectl create secret generic mysecret --from-file=auth=my-htpasswd  Optionally, set  ingress.kubernetes.io/auth-realm  to the basic authentication\nrealm, which is displayed in the password prompt by most browsers.  Most common password hash schemes are supported, including DES, MD5 ( $1$  and $apr1$ ), bcrypt ( $2[abxy]$ ), SHA-256 ( $5$ ) and SHA-512 ( $6$ ), and four\nRFC2307-style hashes:  {PLAIN} ,  {SHA} ,  {SSHA}  and  {CRYPT}  (the first\nthree of which are also supported by nginx).  Security-wise, although the MD5 schemes are extremely weak as password hashes,\nthey are probably fine for any situation where htpasswd-based authentication is\nin use.  The primary security improvement in newer algorithms (e.g. bcrypt and\nSHA-2) is they are slower, which increases the time required to perform an\noffline brute force attack; however, this also increases the time required to check  the password, which leads to unacceptable delays on typical HTML page\nloads.  For example, if you use a bcrypt configuration that takes 200ms to check one\nhash, and you load an HTML page with 20 assets, then you will spend 4 seconds\ndoing nothing but waiting for authentication.  If multiple users are loading\npages at the same time, then things will be even slower once you run out of\nCPUs.  If you need stronger password security than MD5, you should stop using HTTP\nbasic authentication and use another authentication method (like Cookie-based\nauthentication) instead.",
            "title": "Password authentication"
        },
        {
            "location": "/auth/#ip-address-authentication",
            "text": "To enable IP authentication, set the ingress.kubernetes.io/whitelist-source-range  annotation to a comma-delimited\nlist of IP addresses or networks, for example  \"127.0.0.0/8,::1/128\" .  When both IP-based and password-authentication are configured on the same\ningress, you can set the  ingress.kubernetes.io/auth-satisfy  annotation to\neither  any  or  all :    any  will permit the request if either the IP is present in\n   whitelist-source-range  or if the client provides valid basic authentication;\n  otherwise the request will be denied with HTTP 401 Unauthorized.    all  will permit the request if the client IP is present in\n   whitelist-source-range   and  the client also provides valid basic\n  authentication.  If the client IP address is not in the address list, the\n  request will be denied with HTTP 403 Forbidden.  If the IP address is present\n  but the request did not contain valid basic authentication, the request will\n  be denied with HTTP 401 Unauthorized.    To prevent accidental misconfiguration, the default value is  all .  Important : IP address authentication requires that Traffic Server knows the\noriginal IP address of the client making the request.  If TS is serving requests\ndirectly, or sits behind a transparent load balancer that preserves the client\nIP address (such as an Azure service, a GCE network load balancer, or Linux LVS\nin some configurations), then this will be the case; otherwise, it will see all\nrequests as coming from the load balancer's internal IP address, and\nauthentication will not be effective.  We plan to address this limitation in a\nfuture release, using either the  X-Forwarded-For  header field, or the\nso-called Proxy Protocol.  Scalability note: The IP list is implemented as a simple linked list, rather\nthan a more efficient data structure such as a radix tree.  This means that the\nlookup time, and consequently the overall request time, will increase linearly\nas the number of entries in the list increases.  This decision was made because a linked list is a simpler data structure, and\ntherefore performs better with a small number of entries even though performance\nis worse with a larger list.  This trade-off will only become noticeable if you\nhave hundreds or thousands of entries in the address list, which is very\nunlikely in real-world deployments.  (For one thing, it would be extremely\ncumbersome to manage such a large list as an annotation.)  If you require support for such a large number of addresses in a single Ingress,\nplease let us know via a Github issue.",
            "title": "IP address authentication"
        },
        {
            "location": "/external/",
            "text": "Proxying to external services\n\n\nSometimes, you might want to proxy traffic to a service that doesn't run as a\nKubernetes pod.  This can be used to expose external services via an Ingress,\nand to allow the \nfollow-redirects\n annotation to access external resources.\n\n\nExternal proxying via IP address\n\n\nTo proxy requests to a particular IP address or a set of IP address, create a\n\nService\n resource without a selector, and create its associated \nEndpoints\n\nresource:\n\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n\n---\n\nkind: Endpoints\napiVersion: v1\nmetadata:\n  name: external-service\nsubsets:\n- addresses:\n  - ip: 1.2.3.4\n  ports:\n  - port: 80\n\n\n\n\nYou can now define an Ingress to route traffic to this service:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80\n\n\n\n\nTraffic Server will now route requests for \nhttp://external.example.com/\n to your\nexternal service at IP address \n1.2.3.4\n.\n\n\nExternal proxying via hostname\n\n\nTo proxy to an external hostname, create a \nService\n resource of type\n\nExternalName\n:\n\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName\n  externalName: my-external-backend.example.com\n\n\n\n\nYou do not need to configure an \nEndpoints\n resource as with an external IP\naddress.  Create an Ingress for this Service:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\n  annotations:\n    ingress.kubernetes.io/preserve-host: \"false\"\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80\n\n\n\n\nNow requests for \nhttp://external.example.com\n will be proxied to\n\nhttp://my-external-backend.example.com\n.\n\n\nWhen using an ExternalName Service, the \nservicePort\n must be an integer;\nnamed ports are not supported.\n\n\nIn most cases, you will want to set the \npreserve-host\n annotation to \n\"false\"\n\nso that the external service sees the hostname it's expecting, rather than the\nhostname in the client request.\n\n\nExternal proxying and TLS\n\n\nBy default, even if a request uses TLS, it will be proxied to the external\nbackend via HTTP.  To use TLS for the backend, set an annotation on the Ingress:\n\ningress.kubernetes.io/secure-backends: \"true\"\n.  This is not very useful for\nexternal IP addresses, because it's unlikely the backend will have a TLS\ncertificate for its IP address, but it will work well with \nExternalName\n\nservices.\n\n\nFor TLS to work, remember to set \nservicePort\n to \n443\n (or some other suitable\nvalue).",
            "title": "External proxying"
        },
        {
            "location": "/external/#proxying-to-external-services",
            "text": "Sometimes, you might want to proxy traffic to a service that doesn't run as a\nKubernetes pod.  This can be used to expose external services via an Ingress,\nand to allow the  follow-redirects  annotation to access external resources.",
            "title": "Proxying to external services"
        },
        {
            "location": "/external/#external-proxying-via-ip-address",
            "text": "To proxy requests to a particular IP address or a set of IP address, create a Service  resource without a selector, and create its associated  Endpoints \nresource:  kind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n\n---\n\nkind: Endpoints\napiVersion: v1\nmetadata:\n  name: external-service\nsubsets:\n- addresses:\n  - ip: 1.2.3.4\n  ports:\n  - port: 80  You can now define an Ingress to route traffic to this service:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80  Traffic Server will now route requests for  http://external.example.com/  to your\nexternal service at IP address  1.2.3.4 .",
            "title": "External proxying via IP address"
        },
        {
            "location": "/external/#external-proxying-via-hostname",
            "text": "To proxy to an external hostname, create a  Service  resource of type ExternalName :  kind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName\n  externalName: my-external-backend.example.com  You do not need to configure an  Endpoints  resource as with an external IP\naddress.  Create an Ingress for this Service:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\n  annotations:\n    ingress.kubernetes.io/preserve-host: \"false\"\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80  Now requests for  http://external.example.com  will be proxied to http://my-external-backend.example.com .  When using an ExternalName Service, the  servicePort  must be an integer;\nnamed ports are not supported.  In most cases, you will want to set the  preserve-host  annotation to  \"false\" \nso that the external service sees the hostname it's expecting, rather than the\nhostname in the client request.",
            "title": "External proxying via hostname"
        },
        {
            "location": "/external/#external-proxying-and-tls",
            "text": "By default, even if a request uses TLS, it will be proxied to the external\nbackend via HTTP.  To use TLS for the backend, set an annotation on the Ingress: ingress.kubernetes.io/secure-backends: \"true\" .  This is not very useful for\nexternal IP addresses, because it's unlikely the backend will have a TLS\ncertificate for its IP address, but it will work well with  ExternalName \nservices.  For TLS to work, remember to set  servicePort  to  443  (or some other suitable\nvalue).",
            "title": "External proxying and TLS"
        },
        {
            "location": "/tls/",
            "text": "Using TLS\n\n\nConfiguration\n\n\nTLS keys and certificates are taken from Kubernetes Secret resources according\nto the \ntls\n attribute of each Ingress resource.  See the\n\nIngress documentation\n\nfor details on how to configure TLS.\n\n\nTLS Server Name Indication support is required for TLS to work; clients without\nSNI support will receive a TLS negotiation error.  There is no default\ncertificate for non-SNI-capable clients.\n\n\nIf you don't want to use Kubernetes for TLS, set \ntls: false\n in\n\nkubernetes.config\n or set the \n$TS_TLS\n environment variable to \n\"false\"\n.\nYou will need to provide TLS configuration some other way, like\n\nssl_multicert.config\n or the \nssl-cert-loader\n plugin, or else terminate TLS\nbefore traffic reaches Traffic Server.\n\n\nRedirecting HTTP to HTTPS\n\n\nBy default, insecure HTTP requests to an Ingress which has TLS configured will\nbe redirected to HTTPS with an HTTP 301 response.  To disable this behaviour,\nset the \ningress.kubernetes.io/ssl-redirect\n annotation to \nfalse\n.\n\n\nTo force a redirect to HTTPS even when TLS is not configured on the Ingress, set\nthe \ningress.kubernetes.io/force-ssl-redirect\n annotation to \n\"true\"\n.  This\nwill not work unless you are offloading TLS termination in front of Traffic\nServer.\n\n\nConnecting to pods via HTTPS\n\n\nUsually, communication between Traffic Server and backends (e.g. pods) is via\ninsecure HTTP, even if the request was made over HTTPS.  To use HTTPS for\ncommunicate with the backend, set the \ningress.kubernetes.io/secure-backends\n\nannotation to \n\"true\"\n.  This is not very useful when the backend is a pod,\nbecause TS connects to the pod by its IP address, and it's extremely unlikely\nthe pod will have a TLS certificate for that IP address.  However, this can be\nuseful when using \nexternal proxying\n.\n\n\nA better method to secure traffic between Traffic Server and pods is to use a\nnetwork CNI plugin that supports encryption, such as Weave Net.\n\n\nHSTS\n\n\nTo enable HTTP Strict Transport Security (HSTS), set the\n\ningress.kubernetes.io/hsts-max-age\n annotation on the Ingress to the HSTS\nmax-age time in seconds.  To be useful, this should be set to at least six\nmonths (15768000 seconds), but you should start with a lower value and gradually\nincrease it.  Do not set it to a large value without testing it first, because,\nby design, it cannot be turned off for browsers that already saw the HSTS\nheader until the max-age expires.\n\n\nHSTS headers are per-hostname, not per-path.  Therefore, \nhsts-max-age\n can only\nbe set on the Ingress that includes the root path for a particular hostname\n(i.e., where the Ingress rule has no \npath\n attribute).\n\n\nTo apply HSTS to subdomains as well, set the\n\ningress.kubernetes.io/hsts-include-subdomains\n annotation.\n\n\nConfiguring the TLS cypher list\n\n\nYou cannot configure the cypher list on the Ingress level; this was judged to be\ntoo risky, as users are likely to set a cypher list and not keep it up to date\nwith changes in best practice.  (If you require this feature, please open a\n\nGithub issue\n.)\n\n\nTo configure the global cypher list, set \nproxy.config.ssl.server.cipher_suite\n\nin the TS \nrecords.config\n file to an OpenSSL cypher string, or set the\n\n$PROXY_CONFIG_SSL_SERVER_CIPHER_SUITE\n environment variable:\n\n\nPROXY_CONFIG_SSL_SERVER_CIPHER_SUITE=ECDH+AES:DH+AES:RSA+AES:!aNULL:!MD5:!DSS\n\n\n\n\nUsing kube-lego\n\n\nkube-lego\n is a Kubernetes controller\nthat automatically provisions TLS certificates using an ACME provider such as\nLet's Encrypt.  It is ideal for test or staging environments (or even production\nenvironments when domain-validated TLS certificates are sufficient), but it\ncurrently \ndoesn't support\n\nany Ingress controllers other than nginx and GCE.\n\n\nTo use the TS Ingress controller with kube-lego, you should configure kube-lego\nas if you were using the nginx Ingress controller, then tell TS to handle the\n\n\"nginx\"\n Ingress class, either by setting the environment variable\n\n$TS_INGRESS_CLASSES\n to \ntrafficserver nginx\n, or in \nkubernetes.config\n:\n\n\ningress_classes: trafficserver nginx",
            "title": "TLS"
        },
        {
            "location": "/tls/#using-tls",
            "text": "",
            "title": "Using TLS"
        },
        {
            "location": "/tls/#configuration",
            "text": "TLS keys and certificates are taken from Kubernetes Secret resources according\nto the  tls  attribute of each Ingress resource.  See the Ingress documentation \nfor details on how to configure TLS.  TLS Server Name Indication support is required for TLS to work; clients without\nSNI support will receive a TLS negotiation error.  There is no default\ncertificate for non-SNI-capable clients.  If you don't want to use Kubernetes for TLS, set  tls: false  in kubernetes.config  or set the  $TS_TLS  environment variable to  \"false\" .\nYou will need to provide TLS configuration some other way, like ssl_multicert.config  or the  ssl-cert-loader  plugin, or else terminate TLS\nbefore traffic reaches Traffic Server.",
            "title": "Configuration"
        },
        {
            "location": "/tls/#redirecting-http-to-https",
            "text": "By default, insecure HTTP requests to an Ingress which has TLS configured will\nbe redirected to HTTPS with an HTTP 301 response.  To disable this behaviour,\nset the  ingress.kubernetes.io/ssl-redirect  annotation to  false .  To force a redirect to HTTPS even when TLS is not configured on the Ingress, set\nthe  ingress.kubernetes.io/force-ssl-redirect  annotation to  \"true\" .  This\nwill not work unless you are offloading TLS termination in front of Traffic\nServer.",
            "title": "Redirecting HTTP to HTTPS"
        },
        {
            "location": "/tls/#connecting-to-pods-via-https",
            "text": "Usually, communication between Traffic Server and backends (e.g. pods) is via\ninsecure HTTP, even if the request was made over HTTPS.  To use HTTPS for\ncommunicate with the backend, set the  ingress.kubernetes.io/secure-backends \nannotation to  \"true\" .  This is not very useful when the backend is a pod,\nbecause TS connects to the pod by its IP address, and it's extremely unlikely\nthe pod will have a TLS certificate for that IP address.  However, this can be\nuseful when using  external proxying .  A better method to secure traffic between Traffic Server and pods is to use a\nnetwork CNI plugin that supports encryption, such as Weave Net.",
            "title": "Connecting to pods via HTTPS"
        },
        {
            "location": "/tls/#hsts",
            "text": "To enable HTTP Strict Transport Security (HSTS), set the ingress.kubernetes.io/hsts-max-age  annotation on the Ingress to the HSTS\nmax-age time in seconds.  To be useful, this should be set to at least six\nmonths (15768000 seconds), but you should start with a lower value and gradually\nincrease it.  Do not set it to a large value without testing it first, because,\nby design, it cannot be turned off for browsers that already saw the HSTS\nheader until the max-age expires.  HSTS headers are per-hostname, not per-path.  Therefore,  hsts-max-age  can only\nbe set on the Ingress that includes the root path for a particular hostname\n(i.e., where the Ingress rule has no  path  attribute).  To apply HSTS to subdomains as well, set the ingress.kubernetes.io/hsts-include-subdomains  annotation.",
            "title": "HSTS"
        },
        {
            "location": "/tls/#configuring-the-tls-cypher-list",
            "text": "You cannot configure the cypher list on the Ingress level; this was judged to be\ntoo risky, as users are likely to set a cypher list and not keep it up to date\nwith changes in best practice.  (If you require this feature, please open a Github issue .)  To configure the global cypher list, set  proxy.config.ssl.server.cipher_suite \nin the TS  records.config  file to an OpenSSL cypher string, or set the $PROXY_CONFIG_SSL_SERVER_CIPHER_SUITE  environment variable:  PROXY_CONFIG_SSL_SERVER_CIPHER_SUITE=ECDH+AES:DH+AES:RSA+AES:!aNULL:!MD5:!DSS",
            "title": "Configuring the TLS cypher list"
        },
        {
            "location": "/tls/#using-kube-lego",
            "text": "kube-lego  is a Kubernetes controller\nthat automatically provisions TLS certificates using an ACME provider such as\nLet's Encrypt.  It is ideal for test or staging environments (or even production\nenvironments when domain-validated TLS certificates are sufficient), but it\ncurrently  doesn't support \nany Ingress controllers other than nginx and GCE.  To use the TS Ingress controller with kube-lego, you should configure kube-lego\nas if you were using the nginx Ingress controller, then tell TS to handle the \"nginx\"  Ingress class, either by setting the environment variable $TS_INGRESS_CLASSES  to  trafficserver nginx , or in  kubernetes.config :  ingress_classes: trafficserver nginx",
            "title": "Using kube-lego"
        },
        {
            "location": "/cors/",
            "text": "Configuring Cross-Origing Resource Sharing\n\n\nCORS is a method to permit cross-origin HTTP requests in JavaScript, i.e.\nrequests made by JS running on one domain to a page on a different domain.\nThis is usually disallowed for security reasons (it could allow one page to\nsend requests using the user's credentials to another page); CORS provides a\nway to safely permit such requests.\n\n\nFor more information on CORS, see the documentation on the\n\nMozilla Developer Network\n.\n\n\nThere are two ways to configure CORS: either your application can send CORS\nheaders itself, or you can configure the Ingress resource to do so for you.\nIf your application is handling CORS itself, you do not need any of the\nconfiguration described here.\n\n\nBasic CORS configuration\n\n\nTo enable cross-origin requests from any domain, set the\n\ningress.kubernetes.io/enable-cors\n annotation on the Ingress resource:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/enable-cors: \"true\"\n\n\n\n\nThis will allow requests from any origin, with credentials, with the following\nrequest methods: \nGET\n, \nPUT\n, \nPOST\n, and \nDELETE\n.\n\n\nThis must \nonly\n be used for Ingress resources that serve static assets, or\ndynamic pages that do not use any sort of authentication (including cookies);\notherwise, any page on the Internet will be able to steal users' credentials.\n\n\nSetting \nenable-cors: \"true\"\n is equivalent to setting the following annotations:\n\n\ningress.kubernetes.io/access-control-allow-origin: \"*\"\ningress.kubernetes.io/access-control-allow-credentials: \"true\"\ningress.kubernetes.io/access-control-allow-methods: \"GET, PUT, POST, DELETE, OPTIONS\"\ningress.kubernetes.io/access-control-allow-headers: \"DNT, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type, Authorization\"\ningress.kubernetes.io/access-control-max-age: \"1728000\"\n\n\n\n\nNote that the nginx Ingress controller adds \"\nX-CustomHeader\n\" to the CORS\nheader list if \nenable-cors\n is set.  We believe this is a mistake, and the TS\nimplementation will not add that header.\n\n\nAdvanced configuration\n\n\nIf you want to allow cross-origin requests from a specific set of domains, or\nyou want to control the request methods permitted or whether credentials should\nbe sent, do not use \nenable-cors\n; instead, set the\n\ningress.kubernetes.io/access-control-allow-origin\n annotation:\n\n\ningress.kubernetes.io/access-control-allow-origin: \"*\"\n\n\n\n\nor:\n\n\ningress.kubernetes.io/access-control-allow-origin: \"https://mydomain.com https://myothersite.com\"\n\n\n\n\nThe value should be either \n\"*\"\n (meaning all origins) or a whitespace-delimited\nlist of origins.\n\n\nYou can use the following set of annotations to configure other CORS headers\nin the response:\n\n\n\n\ningress.kubernetes.io/access-control-allow-credentials\n\n\ningress.kubernetes.io/access-control-allow-methods\n\n\n`ingress.kubernetes.io/access-control-allow-headers\n\n\ningress.kubernetes.io/access-control-max-age\n\n\n\n\nThere is no default for these values, so you will likely want to set all of\nthem.\n\n\nDo not set \ningress.kubernetes.io/enable-cors\n at the same time as any of the\nother CORS-related annotations; behaviour in that case is undefined.",
            "title": "CORS"
        },
        {
            "location": "/cors/#configuring-cross-origing-resource-sharing",
            "text": "CORS is a method to permit cross-origin HTTP requests in JavaScript, i.e.\nrequests made by JS running on one domain to a page on a different domain.\nThis is usually disallowed for security reasons (it could allow one page to\nsend requests using the user's credentials to another page); CORS provides a\nway to safely permit such requests.  For more information on CORS, see the documentation on the Mozilla Developer Network .  There are two ways to configure CORS: either your application can send CORS\nheaders itself, or you can configure the Ingress resource to do so for you.\nIf your application is handling CORS itself, you do not need any of the\nconfiguration described here.",
            "title": "Configuring Cross-Origing Resource Sharing"
        },
        {
            "location": "/cors/#basic-cors-configuration",
            "text": "To enable cross-origin requests from any domain, set the ingress.kubernetes.io/enable-cors  annotation on the Ingress resource:  metadata:\n  annotations:\n    ingress.kubernetes.io/enable-cors: \"true\"  This will allow requests from any origin, with credentials, with the following\nrequest methods:  GET ,  PUT ,  POST , and  DELETE .  This must  only  be used for Ingress resources that serve static assets, or\ndynamic pages that do not use any sort of authentication (including cookies);\notherwise, any page on the Internet will be able to steal users' credentials.  Setting  enable-cors: \"true\"  is equivalent to setting the following annotations:  ingress.kubernetes.io/access-control-allow-origin: \"*\"\ningress.kubernetes.io/access-control-allow-credentials: \"true\"\ningress.kubernetes.io/access-control-allow-methods: \"GET, PUT, POST, DELETE, OPTIONS\"\ningress.kubernetes.io/access-control-allow-headers: \"DNT, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type, Authorization\"\ningress.kubernetes.io/access-control-max-age: \"1728000\"  Note that the nginx Ingress controller adds \" X-CustomHeader \" to the CORS\nheader list if  enable-cors  is set.  We believe this is a mistake, and the TS\nimplementation will not add that header.",
            "title": "Basic CORS configuration"
        },
        {
            "location": "/cors/#advanced-configuration",
            "text": "If you want to allow cross-origin requests from a specific set of domains, or\nyou want to control the request methods permitted or whether credentials should\nbe sent, do not use  enable-cors ; instead, set the ingress.kubernetes.io/access-control-allow-origin  annotation:  ingress.kubernetes.io/access-control-allow-origin: \"*\"  or:  ingress.kubernetes.io/access-control-allow-origin: \"https://mydomain.com https://myothersite.com\"  The value should be either  \"*\"  (meaning all origins) or a whitespace-delimited\nlist of origins.  You can use the following set of annotations to configure other CORS headers\nin the response:   ingress.kubernetes.io/access-control-allow-credentials  ingress.kubernetes.io/access-control-allow-methods  `ingress.kubernetes.io/access-control-allow-headers  ingress.kubernetes.io/access-control-max-age   There is no default for these values, so you will likely want to set all of\nthem.  Do not set  ingress.kubernetes.io/enable-cors  at the same time as any of the\nother CORS-related annotations; behaviour in that case is undefined.",
            "title": "Advanced configuration"
        },
        {
            "location": "/compression/",
            "text": "HTTP compression\n\n\nHTTP compression allows the response body of an HTTP transation to be compressed\nto reduce its size, saving bandwidth and decreasing page load times.  Both the\ngzip and Brotli algorithms are supported; gzip is the most common and\nwidely-supported algorithm, while Brotli is a newer algorithm specifically\ndesigned to perform well for typical HTTP content (like HTML).\n\n\nSDCH (an experimental delta-compression algorithm) and deflate (an uncommon\ngzip-like format) are not supported.\n\n\nHTTP compression is enabled by default.  To disable compression on an Ingress,\nset the \ningress.kubernetes.io/compress-enable\n annotation to \n\"false\"\n:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/compress-enable: \"false\"\n\n\n\n\nHTTP compression is only used for certain file types.  It doesn't make sense to\ncompress images, for example, since common image file formats already include\ncompression, and a second layer of compression would only waste CPU cycles\nwithout any reduction in file size.\n\n\nBy default, the following content types are compressed:\n\n\n\n\ntext/css\n\n\ntext/x-component\n\n\ntext/plain\n\n\nfont/opentype\n\n\nimage/svg+xml\n\n\nimage/x-icon\n\n\napplication/atom+xml\n\n\napplication/rss+xml\n\n\napplication/javascript\n\n\naplication/x-javascript\n\n\napplication/json\n\n\napplication/vnd.ms-fontobject\n\n\napplication/x-font-ttf\n\n\napplication/x-web-app-manifest+json\n\n\n\n\nThis is a reasonable default list for most sites, but if you want to provide\nyour own list, set the \ningress.kubernetes.io/compress-types\n annotation:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/compress-types: \"test/css application/javascript application/vnd.my-special-type\"\n\n\n\n\nHTTP compression and caching\n\n\nTS always fetches uncompressed documents from the origin server (the application),\nand stores uncompressed pages in its cache.  If the client requests a\ncompressed response, the document is compressed on the fly while sending it to\nthe client.\n\n\nThis avoids a common problem with caching based on the value of the\n\nAccept-Encoding\n header (e.g. using \nVary\n): if a compressed version of the\ndocument is cached, and the client requests an uncompressed version, TS will go\nto the origin to fetch the new version.  If the page has changed and not been\npurged in the mean time, this can lead to different version of the document\nbeing returned depending on whether the client supports compression, leading\nto strange and difficult to debug problems.\n\n\nThe disadvantage of this method is that it increases TS CPU usage; this may\nbecome an issue if you are serving a lot of traffic (several hundred Mbits/sec\nor more).  If this is an issue for you, you can disable compression on the\nIngress, and return compressed responses from your application instead, using\n\nVary: Accept-Encoding\n.\n\n\nWe may implement a more efficient compression mechanism (likely a hybrid of\nthese two options) in a future release.\n\n\nHTTP compression and TLS BREACH\n\n\nDocument types that commonly contain sensitive content (such as \ntext/html\n)\nare not included on the default compression list.  This is because compressing\nthose content types can leave applications open to the TLS\n\nBREACH\n attack, allowing plaintext page\ncontent (such as CSRF tokens) to be recovered from encrypted data.\n\n\nIf you add these content types to the \ncompress-types\n list, especially\n\ntext/html\n, you must ensure your application is not affected; for example if\nyour application:\n\n\n\n\ndoes not include sensitive data in the page body;\n\n\ndoes not use TLS and is therefore insecure anyway;\n\n\nincludes sensitive data in the page body, but does so in a way specifically\n  designed to resist attack via BREACH (for example, Django version 1.10 or\n  newer).\n\n\n\n\nIf you are not certain that your application meets at least one of these\nrequirements, you should not enable compression of HTML.\n\n\nThere are methods to mitigate BREACH in the proxy layer, for example \"length\nhiding\", which obfuscates the length of the returned document by appending\nrandom comment data to the HTML.  We may implement this in a future version if\nthere is any user demand for it.",
            "title": "Compression"
        },
        {
            "location": "/compression/#http-compression",
            "text": "HTTP compression allows the response body of an HTTP transation to be compressed\nto reduce its size, saving bandwidth and decreasing page load times.  Both the\ngzip and Brotli algorithms are supported; gzip is the most common and\nwidely-supported algorithm, while Brotli is a newer algorithm specifically\ndesigned to perform well for typical HTTP content (like HTML).  SDCH (an experimental delta-compression algorithm) and deflate (an uncommon\ngzip-like format) are not supported.  HTTP compression is enabled by default.  To disable compression on an Ingress,\nset the  ingress.kubernetes.io/compress-enable  annotation to  \"false\" :  metadata:\n  annotations:\n    ingress.kubernetes.io/compress-enable: \"false\"  HTTP compression is only used for certain file types.  It doesn't make sense to\ncompress images, for example, since common image file formats already include\ncompression, and a second layer of compression would only waste CPU cycles\nwithout any reduction in file size.  By default, the following content types are compressed:   text/css  text/x-component  text/plain  font/opentype  image/svg+xml  image/x-icon  application/atom+xml  application/rss+xml  application/javascript  aplication/x-javascript  application/json  application/vnd.ms-fontobject  application/x-font-ttf  application/x-web-app-manifest+json   This is a reasonable default list for most sites, but if you want to provide\nyour own list, set the  ingress.kubernetes.io/compress-types  annotation:  metadata:\n  annotations:\n    ingress.kubernetes.io/compress-types: \"test/css application/javascript application/vnd.my-special-type\"",
            "title": "HTTP compression"
        },
        {
            "location": "/compression/#http-compression-and-caching",
            "text": "TS always fetches uncompressed documents from the origin server (the application),\nand stores uncompressed pages in its cache.  If the client requests a\ncompressed response, the document is compressed on the fly while sending it to\nthe client.  This avoids a common problem with caching based on the value of the Accept-Encoding  header (e.g. using  Vary ): if a compressed version of the\ndocument is cached, and the client requests an uncompressed version, TS will go\nto the origin to fetch the new version.  If the page has changed and not been\npurged in the mean time, this can lead to different version of the document\nbeing returned depending on whether the client supports compression, leading\nto strange and difficult to debug problems.  The disadvantage of this method is that it increases TS CPU usage; this may\nbecome an issue if you are serving a lot of traffic (several hundred Mbits/sec\nor more).  If this is an issue for you, you can disable compression on the\nIngress, and return compressed responses from your application instead, using Vary: Accept-Encoding .  We may implement a more efficient compression mechanism (likely a hybrid of\nthese two options) in a future release.",
            "title": "HTTP compression and caching"
        },
        {
            "location": "/compression/#http-compression-and-tls-breach",
            "text": "Document types that commonly contain sensitive content (such as  text/html )\nare not included on the default compression list.  This is because compressing\nthose content types can leave applications open to the TLS BREACH  attack, allowing plaintext page\ncontent (such as CSRF tokens) to be recovered from encrypted data.  If you add these content types to the  compress-types  list, especially text/html , you must ensure your application is not affected; for example if\nyour application:   does not include sensitive data in the page body;  does not use TLS and is therefore insecure anyway;  includes sensitive data in the page body, but does so in a way specifically\n  designed to resist attack via BREACH (for example, Django version 1.10 or\n  newer).   If you are not certain that your application meets at least one of these\nrequirements, you should not enable compression of HTML.  There are methods to mitigate BREACH in the proxy layer, for example \"length\nhiding\", which obfuscates the length of the returned document by appending\nrandom comment data to the HTML.  We may implement this in a future version if\nthere is any user demand for it.",
            "title": "HTTP compression and TLS BREACH"
        },
        {
            "location": "/serverpush/",
            "text": "HTTP/2 Server Push\n\n\nHTTP/2 server push is a mechanism to allow a server to return multiple documents\nin response to a single HTTP request.  Server push can be used to improve page\nload performance when the server knows that a client requesting one document\nwill also request another document; for example, when the client requests an HTML\npage, the server might also include the page's assets in its response.  This\navoids the need for the client to download and parse the HTML before requesting\nthe assets, reducing the total number of HTTP transactions and improving the\npage load time.\n\n\nHowever, server push has the significant disadvantage that the pushed documents\nare \nalways\n sent to the client, even if the client already has them in its\ncache and wouldn't have requested them otherwise.  Thus, pushing every asset\nused on a page can easily reduce performance (and waste bandwidth) by forcing\nthe client to download objects it already has.  We may look at ways of mitigating\nthis on the server side in a future release (by detecting which assets the client\nmight already have), but there is currently no perfect solution to this problem.\n\n\nDeciding when to use server push is a complicated and application-specific issue,\nwhich we won't cover here.  The following article may be helpful:\n\n\n\n\nSmashing Magazine: \"A Comprehensive Guide To HTTP/2 Server Push\"\n\n\n\n\nConfiguring Server Push\n\n\nServer push is enabled by default.  If you want to disable server push on an\nIngress, use the \ningress.kubernetes.io/server-push\n annotation:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/server-push: \"false\"\n\n\n\n\nLike other implementations, Traffic Server uses the \nLink\n header field in the\nHTTP response to determine what content to push to the client.  Processing is\ndone as soon as the response header is received, so if your application is slow\nto generate the response body, it can still begin pushing assets to the client\nonce the header is sent.\n\n\nTo push a document, include a \nLink\n header field in your response with the\n\nrel=preload\n attribute:\n\n\nLink: </path/to/my.css>; rel=preload; as=style\n\n\n\n\nThe argument to the \nas\n attribute should be one of the standard request\ndestinations (\"audio\", \"document\", \"embed\", \"font\", \"image\", \"manifest\", \"object\",\n\"report\", \"script\", \"serviceworker\", \"sharedworker\", \"style\", \"track\", \"video\",\n\"worker\", or \"xslt\") although TS does not enforce this and will push the object\nanyway.\n\n\nIf you want to include a \nrel=preload\n link but not use server push for that\nresource, add the \nnopush\n attribute:\n\n\nLink: </path/to/my/image.jpeg>; rel=preload; as=image; nopush\n\n\n\n\nServer Push and caching\n\n\nBefore TS can push an object to the client, it must have a copy of the object\nitself.  This means you should almost always enable \ncaching\n on\nassets you intend to push; otherwise, the client will have to wait while TS\ngoes back to the application to fetch each pushed asset, and you have lost a\nsignificant fraction of the performance you might gain from using server push.",
            "title": "Server Push"
        },
        {
            "location": "/serverpush/#http2-server-push",
            "text": "HTTP/2 server push is a mechanism to allow a server to return multiple documents\nin response to a single HTTP request.  Server push can be used to improve page\nload performance when the server knows that a client requesting one document\nwill also request another document; for example, when the client requests an HTML\npage, the server might also include the page's assets in its response.  This\navoids the need for the client to download and parse the HTML before requesting\nthe assets, reducing the total number of HTTP transactions and improving the\npage load time.  However, server push has the significant disadvantage that the pushed documents\nare  always  sent to the client, even if the client already has them in its\ncache and wouldn't have requested them otherwise.  Thus, pushing every asset\nused on a page can easily reduce performance (and waste bandwidth) by forcing\nthe client to download objects it already has.  We may look at ways of mitigating\nthis on the server side in a future release (by detecting which assets the client\nmight already have), but there is currently no perfect solution to this problem.  Deciding when to use server push is a complicated and application-specific issue,\nwhich we won't cover here.  The following article may be helpful:   Smashing Magazine: \"A Comprehensive Guide To HTTP/2 Server Push\"",
            "title": "HTTP/2 Server Push"
        },
        {
            "location": "/serverpush/#configuring-server-push",
            "text": "Server push is enabled by default.  If you want to disable server push on an\nIngress, use the  ingress.kubernetes.io/server-push  annotation:  metadata:\n  annotations:\n    ingress.kubernetes.io/server-push: \"false\"  Like other implementations, Traffic Server uses the  Link  header field in the\nHTTP response to determine what content to push to the client.  Processing is\ndone as soon as the response header is received, so if your application is slow\nto generate the response body, it can still begin pushing assets to the client\nonce the header is sent.  To push a document, include a  Link  header field in your response with the rel=preload  attribute:  Link: </path/to/my.css>; rel=preload; as=style  The argument to the  as  attribute should be one of the standard request\ndestinations (\"audio\", \"document\", \"embed\", \"font\", \"image\", \"manifest\", \"object\",\n\"report\", \"script\", \"serviceworker\", \"sharedworker\", \"style\", \"track\", \"video\",\n\"worker\", or \"xslt\") although TS does not enforce this and will push the object\nanyway.  If you want to include a  rel=preload  link but not use server push for that\nresource, add the  nopush  attribute:  Link: </path/to/my/image.jpeg>; rel=preload; as=image; nopush",
            "title": "Configuring Server Push"
        },
        {
            "location": "/serverpush/#server-push-and-caching",
            "text": "Before TS can push an object to the client, it must have a copy of the object\nitself.  This means you should almost always enable  caching  on\nassets you intend to push; otherwise, the client will have to wait while TS\ngoes back to the application to fetch each pushed asset, and you have lost a\nsignificant fraction of the performance you might gain from using server push.",
            "title": "Server Push and caching"
        }
    ]
}