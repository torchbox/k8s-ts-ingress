{
    "docs": [
        {
            "location": "/",
            "text": "Traffic Server ingress controller\n\n\nWARNING: This is alpha code, do not use it in production.\n  (If you do,\nplease report bugs.)\n\n\nApache Traffic Server\n is a high-performance,\nextensible HTTP proxy server with a rich feature set, including TLS termination,\ncaching, and edge-side includes (ESI).  This plugin allows TS to act as an\n\nIngress\n controller for\n\nKubernetes\n clusters, providing the reverse proxy that\nallows HTTP requests from the Internet to reach Kubernetes pods.\n\n\nThe controller is provided as C source code and as a pre-built Docker image.\nIf you want to add Kubernetes support to an existing instance of TS, you should\nbuild the plugin from source.  If you want to deploy TS inside a Kubernetes\ncluster, you can use the pre-built Docker image.\n\n\nQuick start\n\n\nTo deploy the image on an existing Kubernetes 1.6 (or later) cluster:\n\n\n$ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-rbac.yaml | kubectl apply -f -\n$ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-deployment.yaml | kubectl apply -f -\n\n\n\n\n(If you're using 1.5 or earlier, you can still use \nexample-deployment.yaml\n,\nbut if you need RBAC support you will need to convert \nexample-rbac.yaml\n to use\nthe old alpha RBAC API.)\n\n\nThis will start two copies of Traffic Server, each with an emptyDir volume for\ncache storage, listening on node ports 30080 (http) and 30443 (https).   You can\nconfigure an external load balancer of some sort to route incoming traffic to\nthose ports, or use Kubernetes'\n\nkeepalived-vip\n\nto manage a virtual IP address on your cluster.\n\n\nFor more detailed installation instructions, see the documentation for\n\nbuilding from source\n or \nDeploying on Kubernetes\n.\n\n\nFeatures\n\n\nThe controller provides the following features:\n\n\n\n\nFull support for Ingress resources, including many annotations used by other\n  controller implementations;\n\n\nHTTP/2;\n\n\nWebSockets;\n\n\nTLS termination, configured in the Ingress resource using Kubernetes Secrets;\n\n\nCaching of responses, controlled by \nCache-Control\n or \nExpires\n headers,\n  including support for alternatives (the HTTP \nVary\n header field), removal of\n  individual pages from the cache (\nPURGE\n), and fast clearing of the entire\n  cache;\n\n\nAuthorization using HTTP Basic authentication or client IP address;\n\n\nProxying to external (non-Kubernetes) services using Ingress resources;\n\n\nESI (Edge-Side Includes).\n\n\n\n\nMore features are planned for future releases.  If you would like to see a\nparticular feature supported, please\n\nopen a Github issue\n.\n\n\nPlanned features\n\n\nA feature being listed here indicates we are interested in implementing it, but\nprovides no guarantee that it will be implemented within any particular time\nframe, or ever.\n\n\n\n\nTLS client certificate authentication.\n\n\nClient session affinity\n\n\nProxy protocol\n\n\nCross-Origin Resource Sharing\n\n\nRate limiting\n\n\nSSL passthrough\n\n\nGlobal / default configuration\n\n\nPer-ingress gzip configuration\n\n\nHSTS preload support (in any case, rewrite the HSTS support as it will be\n  removed from TS core in some later release)\n\n\nPer-Ingress timeout configuration\n\n\nHTTP/2 server push\n\n\nCustom error bodies\n\n\nImprove API watch support by first retrieving all objects, then watching with resourceVersion.\n\n\n\n\nRelease history\n\n\n\n\n1.0.0-alpha6 (unreleased):\n\n\nThe behaviour of the \napp-root\n annotation was changed to match the\n  behaviour of other Ingress controllers.\n\n\nSeveral annotations were moved from \ningress.kubernetes.io\n to\n  \ningress.kubernetes.io\n to improve compatibility among Ingress\n  controllers.\n\n\n\n\n\n\n1.0.0-alpha5:\n\n\nIncompatible change: The \ningress.kubernetes.io/auth-address-list\n\n    annotation was renamed to \ningress.kubernetes.io/whitelist-source-range\n,\n    and is now comma-delimited, for compatibility with other Ingress\n    controllers.\n\n\nFeature: Support Ingress classes.\n\n\nFeature: The X-Forwarded-Proto header is now (optionally) sent to the\n    backend.\n\n\nFeature: The \ncache-whitelist-params\n and \ncache-ignore-params\n\n    annotations were implemented.\n\n\nFeature: The \ntls_verify\n configuration option was added.\n\n\nImprovement: The API server connection code was reimplemented using cURL,\n    making it more reliable and featureful.\n\n\nBug fix: TLS redirects with an empty URL path could crash.\n\n\nBug fix: TLS secret handling could leak memory.\n\n\nBug fix: with some combinations of Traffic Server and OpenSSL versions,\n    TLS certificates might not be loaded correctly.  Use the new\n    TS_SSL_CERT_HOOK hook to ensure this works properly in all cases.\n\n\nBug fix: An Endpoints with more than one port or address could be parsed\n    incorrectly or cause a crash.\n\n\n\n\n\n\n1.0.0-alpha4:\n\n\nDo not return a client error if the requested host or path was not\n  found, to allow use with other plugins like healthchecks.\n\n\n\n\n\n\n1.0.0-alpha3:\n\n\nGreatly improved unit test coverage.\n\n\nSeveral minor bugs fixed.\n\n\nSupport configuration via environment variables.\n\n\n\n\n\n\n1.0.0-alpha2: Implement IP address authentication.\n\n\n1.0.0-alpha1: Initial release.\n\n\n\n\nLicense and credits\n\n\nThis plugin was developed by Felicity Tarnell (ft@le-Fay.ORG) for\n\nTorchbox Ltd.\n.  Copyright (c) 2016-2017 Torchbox Ltd.\n\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely. This software is provided 'as-is', without any express or implied\nwarranty.\n\n\n\n\ncrypt_bf.c\n was written by Solar Designer, and is released into the public\ndomain.\n\n\ncrypt_des.c\n is copyright (c) 1989, 1993 The Regents of the University of\nCalifornia, based on code written by Tom Truscott.\n\n\nstrmatch.c\n is copyright (c) 1989, 1993, 1994 The Regents of the University\nof California, based on code written by Guido van Rossum.\n\n\ncrypt_md5.c\n was written by Poul-Henning Kamp, and is released under the\n\"beer-ware\" license.\n\n\ncrypt_sha256.c\n and \ncrypt_sha512.c\n were written by Ulrich Drepper, and are\nreleased into the public domain.\n\n\nhash.c\n contains code written by Landon Curt Noll, which is released into the\npublic domain.\n\n\nbase64.c\n is copyright (c) 2011-2017 Felicity Tarnell.",
            "title": "Home"
        },
        {
            "location": "/#traffic-server-ingress-controller",
            "text": "WARNING: This is alpha code, do not use it in production.   (If you do,\nplease report bugs.)  Apache Traffic Server  is a high-performance,\nextensible HTTP proxy server with a rich feature set, including TLS termination,\ncaching, and edge-side includes (ESI).  This plugin allows TS to act as an Ingress  controller for Kubernetes  clusters, providing the reverse proxy that\nallows HTTP requests from the Internet to reach Kubernetes pods.  The controller is provided as C source code and as a pre-built Docker image.\nIf you want to add Kubernetes support to an existing instance of TS, you should\nbuild the plugin from source.  If you want to deploy TS inside a Kubernetes\ncluster, you can use the pre-built Docker image.",
            "title": "Traffic Server ingress controller"
        },
        {
            "location": "/#quick-start",
            "text": "To deploy the image on an existing Kubernetes 1.6 (or later) cluster:  $ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-rbac.yaml | kubectl apply -f -\n$ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-deployment.yaml | kubectl apply -f -  (If you're using 1.5 or earlier, you can still use  example-deployment.yaml ,\nbut if you need RBAC support you will need to convert  example-rbac.yaml  to use\nthe old alpha RBAC API.)  This will start two copies of Traffic Server, each with an emptyDir volume for\ncache storage, listening on node ports 30080 (http) and 30443 (https).   You can\nconfigure an external load balancer of some sort to route incoming traffic to\nthose ports, or use Kubernetes' keepalived-vip \nto manage a virtual IP address on your cluster.  For more detailed installation instructions, see the documentation for building from source  or  Deploying on Kubernetes .",
            "title": "Quick start"
        },
        {
            "location": "/#features",
            "text": "The controller provides the following features:   Full support for Ingress resources, including many annotations used by other\n  controller implementations;  HTTP/2;  WebSockets;  TLS termination, configured in the Ingress resource using Kubernetes Secrets;  Caching of responses, controlled by  Cache-Control  or  Expires  headers,\n  including support for alternatives (the HTTP  Vary  header field), removal of\n  individual pages from the cache ( PURGE ), and fast clearing of the entire\n  cache;  Authorization using HTTP Basic authentication or client IP address;  Proxying to external (non-Kubernetes) services using Ingress resources;  ESI (Edge-Side Includes).   More features are planned for future releases.  If you would like to see a\nparticular feature supported, please open a Github issue .",
            "title": "Features"
        },
        {
            "location": "/#planned-features",
            "text": "A feature being listed here indicates we are interested in implementing it, but\nprovides no guarantee that it will be implemented within any particular time\nframe, or ever.   TLS client certificate authentication.  Client session affinity  Proxy protocol  Cross-Origin Resource Sharing  Rate limiting  SSL passthrough  Global / default configuration  Per-ingress gzip configuration  HSTS preload support (in any case, rewrite the HSTS support as it will be\n  removed from TS core in some later release)  Per-Ingress timeout configuration  HTTP/2 server push  Custom error bodies  Improve API watch support by first retrieving all objects, then watching with resourceVersion.",
            "title": "Planned features"
        },
        {
            "location": "/#release-history",
            "text": "1.0.0-alpha6 (unreleased):  The behaviour of the  app-root  annotation was changed to match the\n  behaviour of other Ingress controllers.  Several annotations were moved from  ingress.kubernetes.io  to\n   ingress.kubernetes.io  to improve compatibility among Ingress\n  controllers.    1.0.0-alpha5:  Incompatible change: The  ingress.kubernetes.io/auth-address-list \n    annotation was renamed to  ingress.kubernetes.io/whitelist-source-range ,\n    and is now comma-delimited, for compatibility with other Ingress\n    controllers.  Feature: Support Ingress classes.  Feature: The X-Forwarded-Proto header is now (optionally) sent to the\n    backend.  Feature: The  cache-whitelist-params  and  cache-ignore-params \n    annotations were implemented.  Feature: The  tls_verify  configuration option was added.  Improvement: The API server connection code was reimplemented using cURL,\n    making it more reliable and featureful.  Bug fix: TLS redirects with an empty URL path could crash.  Bug fix: TLS secret handling could leak memory.  Bug fix: with some combinations of Traffic Server and OpenSSL versions,\n    TLS certificates might not be loaded correctly.  Use the new\n    TS_SSL_CERT_HOOK hook to ensure this works properly in all cases.  Bug fix: An Endpoints with more than one port or address could be parsed\n    incorrectly or cause a crash.    1.0.0-alpha4:  Do not return a client error if the requested host or path was not\n  found, to allow use with other plugins like healthchecks.    1.0.0-alpha3:  Greatly improved unit test coverage.  Several minor bugs fixed.  Support configuration via environment variables.    1.0.0-alpha2: Implement IP address authentication.  1.0.0-alpha1: Initial release.",
            "title": "Release history"
        },
        {
            "location": "/#license-and-credits",
            "text": "This plugin was developed by Felicity Tarnell (ft@le-Fay.ORG) for Torchbox Ltd. .  Copyright (c) 2016-2017 Torchbox Ltd.  Permission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely. This software is provided 'as-is', without any express or implied\nwarranty.   crypt_bf.c  was written by Solar Designer, and is released into the public\ndomain.  crypt_des.c  is copyright (c) 1989, 1993 The Regents of the University of\nCalifornia, based on code written by Tom Truscott.  strmatch.c  is copyright (c) 1989, 1993, 1994 The Regents of the University\nof California, based on code written by Guido van Rossum.  crypt_md5.c  was written by Poul-Henning Kamp, and is released under the\n\"beer-ware\" license.  crypt_sha256.c  and  crypt_sha512.c  were written by Ulrich Drepper, and are\nreleased into the public domain.  hash.c  contains code written by Landon Curt Noll, which is released into the\npublic domain.  base64.c  is copyright (c) 2011-2017 Felicity Tarnell.",
            "title": "License and credits"
        },
        {
            "location": "/source/",
            "text": "Installing the plugin from source\n\n\nIf you want to integrate Kubernetes with an existing Traffic Server installation,\nyou can build the plugin from source.  If you're planning to deploy the plugin\ninside a Kubernetes cluster, you should read \nUsing the Docker image\n\ninstead.\n\n\nRequirements\n\n\nThe following are required to build:\n\n\n\n\nTraffic Server 7.0 or later (including development headers).  Older versions\n  might work, but are not tested or supported.\n\n\nA working C99 compiler and \nmake\n utility.\n\n\njson-c library\n\n\ncURL library\n\n\nOpenSSL (or a compatible TLS library, e.g. LibreSSL)\n\n\n\n\nIf you want to run the unit tests, a C++11 compiler is required.  If you want to\nrun the end-to-end tests, a Linux/amd64 host is required (because those tests\nrequire running the Kubernetes API server).\n\n\nBuilding\n\n\nTo build and install the plugin:\n\n\n$ autoreconf -if            # only if building from a git checkout\n$ ./configure [--with-tsxs=/path/to/trafficserver/bin/tsxs]\n$ make\n$ make install\n\n\n\n\nThis will put \nkubernetes.so\n in your Traffic Server plugins directory.  Edit\n\nplugin.config\n to tell Traffic Server to load the plugin.\n\n\nTo run the unit tests:\n\n\n$ make test\n\n\n\n\nTo run the end-to-end tests:\n\n\n$ tests/e2erun.sh\n\n\n\n\nConfiguration\n\n\nIf Traffic Server is not running inside the cluster, you will need to provide a\n\nkubernetes.config\n configuration file.  See \nConfiguration\n for\ndetails.\n\n\nIf TS is running inside the cluster, it will pick up its service account details\nautomatically and the configuration file is not required, but you will need to\nensure it has access to the resources it needs to run.  If you're using RBAC\nfor authorization, see \nrbac.yaml\n for an example RBAC configuration.",
            "title": "Installing from source"
        },
        {
            "location": "/source/#installing-the-plugin-from-source",
            "text": "If you want to integrate Kubernetes with an existing Traffic Server installation,\nyou can build the plugin from source.  If you're planning to deploy the plugin\ninside a Kubernetes cluster, you should read  Using the Docker image \ninstead.",
            "title": "Installing the plugin from source"
        },
        {
            "location": "/source/#requirements",
            "text": "The following are required to build:   Traffic Server 7.0 or later (including development headers).  Older versions\n  might work, but are not tested or supported.  A working C99 compiler and  make  utility.  json-c library  cURL library  OpenSSL (or a compatible TLS library, e.g. LibreSSL)   If you want to run the unit tests, a C++11 compiler is required.  If you want to\nrun the end-to-end tests, a Linux/amd64 host is required (because those tests\nrequire running the Kubernetes API server).",
            "title": "Requirements"
        },
        {
            "location": "/source/#building",
            "text": "To build and install the plugin:  $ autoreconf -if            # only if building from a git checkout\n$ ./configure [--with-tsxs=/path/to/trafficserver/bin/tsxs]\n$ make\n$ make install  This will put  kubernetes.so  in your Traffic Server plugins directory.  Edit plugin.config  to tell Traffic Server to load the plugin.  To run the unit tests:  $ make test  To run the end-to-end tests:  $ tests/e2erun.sh",
            "title": "Building"
        },
        {
            "location": "/source/#configuration",
            "text": "If Traffic Server is not running inside the cluster, you will need to provide a kubernetes.config  configuration file.  See  Configuration  for\ndetails.  If TS is running inside the cluster, it will pick up its service account details\nautomatically and the configuration file is not required, but you will need to\nensure it has access to the resources it needs to run.  If you're using RBAC\nfor authorization, see  rbac.yaml  for an example RBAC configuration.",
            "title": "Configuration"
        },
        {
            "location": "/docker/",
            "text": "Using the Docker image on Kubernetes\n\n\nWe provide two examples Kubernetes deployments for the TS ingress controller:\n\n\n\n\nexample-daemonset.yaml\n uses a DaemonSet, with an example of using node\n  taints and affinity to run the controller only on master nodes, and exposes\n  TS using a hostPort;\n\n\nexample-deployment.yaml\n uses a Deployment, with a nodePort Service used to\n  expose TS.\n\n\n\n\nYou will probably want to read and edit one of these files before using it.\n\n\nUnfortunately, there are many different ways to expose an Ingress controller on\nKubernetes, and we can't document every possible variation, so you will need to\ndecide what method is best for your cluster.\n\n\nRuntime configuration\n\n\nMost Traffic Server configuration (\nrecords.config\n entries) can be changed\nusing environment variables; see the\n\nTraffic Server Documentation\n.  For example, to make Traffic Server listen on port 7080 for HTTP requests,\nset \nPROXY_CONFIG_HTTP_SERVER_PORTS=7080\n.\n\n\nThe TS Docker image provides one additional environment variable:\n\n\n\n\nTS_CACHE_SIZE=nnn\n: Size of the on-disk cache file to create, in megabytes.\n\n\n\n\nCache storage\n\n\nThe example deployment resources use an \nemptyDir\n for cache storage.  This\nmeans the cache will persist across node reboots, but will we cleared if the\npod is move to a different node, or if it's upgraded (which deletes the old pod).\n\n\nThe cache file will be created automatically on startup if it doesn't exist.\n\n\nFor persistent cache storage, mount a volume on \n/var/lib/trafficserver\n. \nHowever, be aware that only one instance of TS can access the cache at once.  If\nyou are running multiple copies, you will need to create a separate PV for each\ninstance (perhaps by using a StatefulSet instead of a DaemonSet).",
            "title": "Using the Docker Image"
        },
        {
            "location": "/docker/#using-the-docker-image-on-kubernetes",
            "text": "We provide two examples Kubernetes deployments for the TS ingress controller:   example-daemonset.yaml  uses a DaemonSet, with an example of using node\n  taints and affinity to run the controller only on master nodes, and exposes\n  TS using a hostPort;  example-deployment.yaml  uses a Deployment, with a nodePort Service used to\n  expose TS.   You will probably want to read and edit one of these files before using it.  Unfortunately, there are many different ways to expose an Ingress controller on\nKubernetes, and we can't document every possible variation, so you will need to\ndecide what method is best for your cluster.",
            "title": "Using the Docker image on Kubernetes"
        },
        {
            "location": "/docker/#runtime-configuration",
            "text": "Most Traffic Server configuration ( records.config  entries) can be changed\nusing environment variables; see the Traffic Server Documentation .  For example, to make Traffic Server listen on port 7080 for HTTP requests,\nset  PROXY_CONFIG_HTTP_SERVER_PORTS=7080 .  The TS Docker image provides one additional environment variable:   TS_CACHE_SIZE=nnn : Size of the on-disk cache file to create, in megabytes.",
            "title": "Runtime configuration"
        },
        {
            "location": "/docker/#cache-storage",
            "text": "The example deployment resources use an  emptyDir  for cache storage.  This\nmeans the cache will persist across node reboots, but will we cleared if the\npod is move to a different node, or if it's upgraded (which deletes the old pod).  The cache file will be created automatically on startup if it doesn't exist.  For persistent cache storage, mount a volume on  /var/lib/trafficserver . \nHowever, be aware that only one instance of TS can access the cache at once.  If\nyou are running multiple copies, you will need to create a separate PV for each\ninstance (perhaps by using a StatefulSet instead of a DaemonSet).",
            "title": "Cache storage"
        },
        {
            "location": "/classes/",
            "text": "Using multiple Ingress controllers\n\n\nIf you want to deploy more than one Ingress controller inside a cluster (for\nexample, to test the TS Ingress controller before deploying it properly), you\nwill need to use Ingress classes to control which resources should be handled\nby which controller.\n\n\nThe Ingress class is set as an annotation on the resource:\n\n\nmetadata:\n  annotations:\n    kubernetes.io/ingress.class: \"trafficserver\"\n\n\n\n\nThe TS Ingress controller will handle any Ingress resource which does not have\nan Ingress class set, or where the Ingress class is set to \"trafficserver\".\n\n\nTo change the Ingress classes that TS will handle, set \ningress_classes\n in\n\nkubernetes.config\n (or the \n$TS_INGRESS_CLASSES\n environment variable) to a\nwhitespace-separate list of values, e.g. \n\"trafficserver ts-staging\"\n.  This\ncan be used to run multiple copies of the TS Ingress controller in one cluster.\nIf you do this, the \ntrafficserver\n class will not be handled unless you\nexplicitly include it in the list.\n\n\nFor more information, see\n\nUsing Multiple Ingress Controller\n\nin the Kubernetes documentation.",
            "title": "Using multiple Ingress controllers"
        },
        {
            "location": "/classes/#using-multiple-ingress-controllers",
            "text": "If you want to deploy more than one Ingress controller inside a cluster (for\nexample, to test the TS Ingress controller before deploying it properly), you\nwill need to use Ingress classes to control which resources should be handled\nby which controller.  The Ingress class is set as an annotation on the resource:  metadata:\n  annotations:\n    kubernetes.io/ingress.class: \"trafficserver\"  The TS Ingress controller will handle any Ingress resource which does not have\nan Ingress class set, or where the Ingress class is set to \"trafficserver\".  To change the Ingress classes that TS will handle, set  ingress_classes  in kubernetes.config  (or the  $TS_INGRESS_CLASSES  environment variable) to a\nwhitespace-separate list of values, e.g.  \"trafficserver ts-staging\" .  This\ncan be used to run multiple copies of the TS Ingress controller in one cluster.\nIf you do this, the  trafficserver  class will not be handled unless you\nexplicitly include it in the list.  For more information, see Using Multiple Ingress Controller \nin the Kubernetes documentation.",
            "title": "Using multiple Ingress controllers"
        },
        {
            "location": "/config/",
            "text": "Configuration\n\n\nThere are two ways to configure the controller: you can pass a configuration\nfile to the plugin in \nplugin.config\n, or you can set the configuration in the\nenvironment.  If a configuration option is set in both the configuration file\nand the environment, the value from the environment takes precedence.\n\n\nTo load a configuration file, pass its name as an argument to the plugin in\n\nplugin.config\n:\n\n\nkubernetes.so /path/to/kubernetes.config\n\n\n\n\nIf the configuration filename is a relative pathname, it will be loaded from\nTS's configuration directory (the place where \nrecords.config\n is located).\n\n\nIf you're deploying from the Docker image, using environment variables is the\nrecommended method; you would have to rebuild the Docker image to add a\nconfiguration file.\n\n\nKubernetes API server configuration\n\n\nIf TS is running inside the cluster, you do not need to configure the API\nserver connection details; they will be picked up automatically from the pod's\nservice account.  However, if you are running outside the cluster you need to\nspecify the API server URL and any credentials required to authenticate to it.\n\n\n\n\n\n\nserver: <url>\n: set the URL (http or https) of the API server the controller\n  should connect to.  (\n$TS_SERVER\n)\n\n\n\n\n\n\ncafile: <filename>\n: the filename of a PEM-encoded certificate file or\n  bundle that will be used to validate a TLS connection to the API server.\n  Ignored if the connection to the API server does not use TLS.  (\n$TS_CAFILE\n)\n\n\n\n\n\n\nverify_tls: <true|false>\n: whether to verify the API server's TLS certificate.\n  There should be no need to disable this.  (\n$TS_VERIFY_TLS\n)\n\n\n\n\n\n\ncertfile: <filename>\n: the filename of a PEM-encoded TLS certificate that\n  will be used to authenticate to the API server.  If set, you must supply a TLS\n  key as well. (\n$TS_CERTFILE\n)\n\n\n\n\n\n\nkeyfile: <filename>\n: the filename of a PEM-encoded TLS key that will be used\n  to authenticate to the API server.  If set, you must supply a TLS certificate\n  as well.  (\n$TS_KEYFILE\n)\n\n\n\n\n\n\ntoken: <token>\n: an authentication Bearer token that will be used to\n  authenticate to the API server, if using token authentication.  (\n$TS_TOKEN\n)\n\n\n\n\n\n\nGlobal configuration\n\n\n\n\n\n\ningress_classes: <class> [<class> ...]\n: a list of Ingress classes that the\n  controller will process.  See \nUsing multiple Ingress classes\n for\n  more information on this option. Default: \ntrafficserver\n.\n  (\n$TS_INGRESS_CLASSES\n)\n\n\n\n\n\n\ntls: <true|false>\n: whether to handle TLS certificates.  If set to \nfalse\n,\n  you will need to load TLS certificates by some other mechanism.  Default:\n  \ntrue\n.  (\n$TS_TLS\n)\n\n\n\n\n\n\nremap: <true|false>\n: whether to handle host and path remapping.  If set to\n  \nfalse\n, only TLS certificate loading will be done.  Default: \ntrue\n.\n  (\n$TS_REMAP\n)\n\n\n\n\n\n\nx_forwarded_proto: <true|false>\n: whether to send an \nX-Forwarded-Proto\n\n  header to backends, containing the client protocol (\nhttp\n or \nhttps\n).\n  Default: \ntrue\n.  (\n$TS_X_FORWARDED_PROTO\n)",
            "title": "Configuration"
        },
        {
            "location": "/config/#configuration",
            "text": "There are two ways to configure the controller: you can pass a configuration\nfile to the plugin in  plugin.config , or you can set the configuration in the\nenvironment.  If a configuration option is set in both the configuration file\nand the environment, the value from the environment takes precedence.  To load a configuration file, pass its name as an argument to the plugin in plugin.config :  kubernetes.so /path/to/kubernetes.config  If the configuration filename is a relative pathname, it will be loaded from\nTS's configuration directory (the place where  records.config  is located).  If you're deploying from the Docker image, using environment variables is the\nrecommended method; you would have to rebuild the Docker image to add a\nconfiguration file.",
            "title": "Configuration"
        },
        {
            "location": "/config/#kubernetes-api-server-configuration",
            "text": "If TS is running inside the cluster, you do not need to configure the API\nserver connection details; they will be picked up automatically from the pod's\nservice account.  However, if you are running outside the cluster you need to\nspecify the API server URL and any credentials required to authenticate to it.    server: <url> : set the URL (http or https) of the API server the controller\n  should connect to.  ( $TS_SERVER )    cafile: <filename> : the filename of a PEM-encoded certificate file or\n  bundle that will be used to validate a TLS connection to the API server.\n  Ignored if the connection to the API server does not use TLS.  ( $TS_CAFILE )    verify_tls: <true|false> : whether to verify the API server's TLS certificate.\n  There should be no need to disable this.  ( $TS_VERIFY_TLS )    certfile: <filename> : the filename of a PEM-encoded TLS certificate that\n  will be used to authenticate to the API server.  If set, you must supply a TLS\n  key as well. ( $TS_CERTFILE )    keyfile: <filename> : the filename of a PEM-encoded TLS key that will be used\n  to authenticate to the API server.  If set, you must supply a TLS certificate\n  as well.  ( $TS_KEYFILE )    token: <token> : an authentication Bearer token that will be used to\n  authenticate to the API server, if using token authentication.  ( $TS_TOKEN )",
            "title": "Kubernetes API server configuration"
        },
        {
            "location": "/config/#global-configuration",
            "text": "ingress_classes: <class> [<class> ...] : a list of Ingress classes that the\n  controller will process.  See  Using multiple Ingress classes  for\n  more information on this option. Default:  trafficserver .\n  ( $TS_INGRESS_CLASSES )    tls: <true|false> : whether to handle TLS certificates.  If set to  false ,\n  you will need to load TLS certificates by some other mechanism.  Default:\n   true .  ( $TS_TLS )    remap: <true|false> : whether to handle host and path remapping.  If set to\n   false , only TLS certificate loading will be done.  Default:  true .\n  ( $TS_REMAP )    x_forwarded_proto: <true|false> : whether to send an  X-Forwarded-Proto \n  header to backends, containing the client protocol ( http  or  https ).\n  Default:  true .  ( $TS_X_FORWARDED_PROTO )",
            "title": "Global configuration"
        },
        {
            "location": "/annotations/",
            "text": "Ingress annotations\n\n\nThe behaviour of an Ingress can be configured by setting annotations on the\nIngress resource, e.g.:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/rewrite-target: '/myapp'\n\n\n\n\nAnnotations whose names with \ningress.kubernetes.io\n are standard annotations\nsupported by most Ingress controllers; those beginning with\n\ningress.kubernetes.io\n are specific to the Traffic Server Ingress controller.\n\n\n\n\n\n\ningress.kubernetes.io/rewrite-target\n: if set to a string, the portion of the\n  request path matched by the Ingress \npath\n attribute will be replaced with\n  this string.  This has no effect on an Ingress without a \npath\n set.\n\n\n\n\n\n\ningress.kubernetes.io/app-root\n: if set to a path, requests for \n/\n will be\n  redirected to this path.  This can be used for applications which sit in a\n  subdirectory rather than at the root.\n\n\n\n\n\n\ningress.kubernetes.io/follow-redirects\n: if \n\"true\"\n, Traffic Server will\n  follow 3xx redirect responses and serve the final response to the client.\n  If the redirect destination is cached, it will be cached with the cache key\n  of the original request.  Redirects will only be followed to other Ingress\n  resources, not to arbitrary destinations (but see below about proxying to\n  external resources).\n\n\n\n\n\n\ningress.kubernetes.io/preserve-host\n: if \n\"false\"\n, set the \nHost\n header\n  in the request to the backend name (e.g., the pod name), instead of the\n  original request host.",
            "title": "Annotations"
        },
        {
            "location": "/annotations/#ingress-annotations",
            "text": "The behaviour of an Ingress can be configured by setting annotations on the\nIngress resource, e.g.:  metadata:\n  annotations:\n    ingress.kubernetes.io/rewrite-target: '/myapp'  Annotations whose names with  ingress.kubernetes.io  are standard annotations\nsupported by most Ingress controllers; those beginning with ingress.kubernetes.io  are specific to the Traffic Server Ingress controller.    ingress.kubernetes.io/rewrite-target : if set to a string, the portion of the\n  request path matched by the Ingress  path  attribute will be replaced with\n  this string.  This has no effect on an Ingress without a  path  set.    ingress.kubernetes.io/app-root : if set to a path, requests for  /  will be\n  redirected to this path.  This can be used for applications which sit in a\n  subdirectory rather than at the root.    ingress.kubernetes.io/follow-redirects : if  \"true\" , Traffic Server will\n  follow 3xx redirect responses and serve the final response to the client.\n  If the redirect destination is cached, it will be cached with the cache key\n  of the original request.  Redirects will only be followed to other Ingress\n  resources, not to arbitrary destinations (but see below about proxying to\n  external resources).    ingress.kubernetes.io/preserve-host : if  \"false\" , set the  Host  header\n  in the request to the backend name (e.g., the pod name), instead of the\n  original request host.",
            "title": "Ingress annotations"
        },
        {
            "location": "/caching/",
            "text": "Using HTTP caching\n\n\nTraffic Server can cache HTTP and HTTPS responses from an application to improve\npage load speed.  On a site which serves a large amount of infrequently\nchanging pages to anonymous users, caching can provide a significant improvement\nto both performance and page load times.  It's not uncommon to see caching\nimprove a site's capacity from tens of requests per second to tens of thousands\nof requests per second, without using any additional resources (except for\nbandwidth, of course).\n\n\nConfiguring caching\n\n\nCaching is enabled on Ingress resources by default.  To indicate that a response\nis to be cached, your application should send a \nCache-Control\n header field in\nthe response:\n\n\nHTTP/1.1 200 OK\nCache-Control: public, max-age=3600\nContent-Type: text/html; charset=UTF-8\n...\n\n\n\n\nLike most HTTP header fields, this is a comma-separated list of values.  \npublic\n\nindicates that the page content does not contain private data (meaning it should\nbe cached by multi-user proxies like Traffic Server), and \nmax-age\n indicates how\nlong it should be cached for; in this case, 3600 seconds or one hour.\n\n\nAs an alternative to \nCache-Control\n, your application can send an \nExpires\n\nheader field containing a timestamp; the page will be cached until the expiry\ntime is reached.  \nExpires\n is not recommended for new applications, since\n\nCache-Control\n is more flexible and has better defined semantics.\n\n\nDisabling caching\n\n\nIf you want to prevent certain pages from being cached, you can indicate this\nusing \nCache-Control\n:\n\n\nHTTP/1.1 200 OK\nCache-Control: no-cache, no-store\n\n\n\n\nYou should generally do this for any personalised pages, e.g. pages served to\nlogged-in users, or pages containing a \nSet-Cookie\n header field.  By default,\nTS will not use the cache for requests containing a \nCookie\n header field or\ncache responses containing a \nSet-Cookie\n field, but it's better to be explicit.\n\n\nTo disable caching entirely on an Ingress, even if it sends \nCache-Control\n or\n\nExpires\n header fields, use the \ningress.kubernetes.io/cache-enable\n annotation:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"\n\n\n\n\nIf only some paths should have caching disabled, you can create another Ingress\nresource for that particular path:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"\n  name: echoheaders\nspec:\n  rules:\n  - host: www.mysite.path\n    http:\n      paths:\n      - path: /admin\n        backend:\n          serviceName: myapp\n          servicePort: http\n\n\n\n\nCaching and URL parameters\n\n\nWhen a page is cached, its URL parameters are stored in the cache to ensure that\na request with different URL parameters returns the correct content.  For\nexample, the URL:\n\n\nhttp://www.mysite.com/listings/?page=1\n\n\n\n\nwill be cached differently from the URL:\n\n\nhttp://www.mysite.com/listings/?page=2\n\n\n\n\nUsually this is what you want and no additional configuration is required.\nHowever, sometimes clients may request pages with additional URL parameters\nwhich do not affect page content.  A good example of this is marketing tracking\nparameters like \nutm_medium\n which are used by JavaScript on the page to\nidentify traffic sources, but do not affect the page content at all.  Because\nthese URL parameters do not affect page content, they should not be considered\nwhen caching.  (The JavaScript tracking code will run anyway, so no data is\nlost.)\n\n\nThere are two approaches to configuring this: either you can set a list of URL\nparameters which should be ignored when caching (which is the safest method),\nor you can set a whitelist of parameters, where any parameters not in the\nlist will be ignored.\n\n\nTo exclude a set of parameters from caching, set the\n\ningress.kubernetes.io/cache-ignore-query-params\n annotation on the Ingress:\n\n\n    ingress.kubernetes.io/cache-ignore-query-params: \"utm_* source_id\"\n\n\n\n\nThe value should be a list of UNIX globs (\n*\n, \n?\n and \n[...]\n are supported);\nany matching query parameters will be ignored for caching.\n\n\nTo set a whitelist of URL parameters, set the\n\ningress.kubernetes.io/cache-whitelist-query-params\n annotation:\n\n\n    ingress.kubernetes.io/cache-whitelist-query-params: \"page view include_id_*\"\n\n\n\n\nThe format is the same as \ncache-ignore-query-params\n, but the meaning is\nreversed: any URL parameter not matched will be ignored.\n\n\nWhen using either of these annotations, you probably also want to set\n\ningress.kubernetes.io/cache-sort-query-params: \"true\"\n, which will cause the\nURL parameters to be lexically sorted.  This means that a request for\n\n/?a=1&b=2\n can be served a cached response for\n/?b=2&a=1\n, improving cache hit\nrate across clients.\n\n\nThese annotations also change the query string sent to the application.  This is\nto ensure the application doesn't accidentally vary the page content based on a\nquery parameter that has been ignored for caching.\n\n\nRemoving pages from the cache\n\n\nRemoving individual URLs\n\n\nYou can purge individual URLs from the cache by sending an HTTP \nPURGE\n request\nto Traffic Server.  To make this easy to do from pods, create a Service for the\nTS pod.  The PURGE request should look like this:\n\n\nPURGE http://www.mysite.com/mypage.html HTTP/1.0\n\n\n\n\nUnfortunately, this doesn't work very well when multiple copies of TS are\nrunning, since there's no simple way for an application to retrieve the list of\nTS instances.  We plan to address this in a future release.\n\n\nClearing the entire cache\n\n\nOccasionally, you might want to clear the cache for an entire domain, for\nexample if some boilerplate HTML has changed that affects all pages.  To do this,\nset the \ningress.kubernetes.io/cache-generation\n annotation to a non-zero\ninteger.  This changes the cache generation for the Ingress; any objects cached\nwith a different generation are no longer visible, and have been effectively\nremoved from the cache.  Typically the cache generation would be set to the\ncurrent UNIX timestamp, although any non-zero integer will work.",
            "title": "Caching"
        },
        {
            "location": "/caching/#using-http-caching",
            "text": "Traffic Server can cache HTTP and HTTPS responses from an application to improve\npage load speed.  On a site which serves a large amount of infrequently\nchanging pages to anonymous users, caching can provide a significant improvement\nto both performance and page load times.  It's not uncommon to see caching\nimprove a site's capacity from tens of requests per second to tens of thousands\nof requests per second, without using any additional resources (except for\nbandwidth, of course).",
            "title": "Using HTTP caching"
        },
        {
            "location": "/caching/#configuring-caching",
            "text": "Caching is enabled on Ingress resources by default.  To indicate that a response\nis to be cached, your application should send a  Cache-Control  header field in\nthe response:  HTTP/1.1 200 OK\nCache-Control: public, max-age=3600\nContent-Type: text/html; charset=UTF-8\n...  Like most HTTP header fields, this is a comma-separated list of values.   public \nindicates that the page content does not contain private data (meaning it should\nbe cached by multi-user proxies like Traffic Server), and  max-age  indicates how\nlong it should be cached for; in this case, 3600 seconds or one hour.  As an alternative to  Cache-Control , your application can send an  Expires \nheader field containing a timestamp; the page will be cached until the expiry\ntime is reached.   Expires  is not recommended for new applications, since Cache-Control  is more flexible and has better defined semantics.",
            "title": "Configuring caching"
        },
        {
            "location": "/caching/#disabling-caching",
            "text": "If you want to prevent certain pages from being cached, you can indicate this\nusing  Cache-Control :  HTTP/1.1 200 OK\nCache-Control: no-cache, no-store  You should generally do this for any personalised pages, e.g. pages served to\nlogged-in users, or pages containing a  Set-Cookie  header field.  By default,\nTS will not use the cache for requests containing a  Cookie  header field or\ncache responses containing a  Set-Cookie  field, but it's better to be explicit.  To disable caching entirely on an Ingress, even if it sends  Cache-Control  or Expires  header fields, use the  ingress.kubernetes.io/cache-enable  annotation:  metadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"  If only some paths should have caching disabled, you can create another Ingress\nresource for that particular path:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"\n  name: echoheaders\nspec:\n  rules:\n  - host: www.mysite.path\n    http:\n      paths:\n      - path: /admin\n        backend:\n          serviceName: myapp\n          servicePort: http",
            "title": "Disabling caching"
        },
        {
            "location": "/caching/#caching-and-url-parameters",
            "text": "When a page is cached, its URL parameters are stored in the cache to ensure that\na request with different URL parameters returns the correct content.  For\nexample, the URL:  http://www.mysite.com/listings/?page=1  will be cached differently from the URL:  http://www.mysite.com/listings/?page=2  Usually this is what you want and no additional configuration is required.\nHowever, sometimes clients may request pages with additional URL parameters\nwhich do not affect page content.  A good example of this is marketing tracking\nparameters like  utm_medium  which are used by JavaScript on the page to\nidentify traffic sources, but do not affect the page content at all.  Because\nthese URL parameters do not affect page content, they should not be considered\nwhen caching.  (The JavaScript tracking code will run anyway, so no data is\nlost.)  There are two approaches to configuring this: either you can set a list of URL\nparameters which should be ignored when caching (which is the safest method),\nor you can set a whitelist of parameters, where any parameters not in the\nlist will be ignored.  To exclude a set of parameters from caching, set the ingress.kubernetes.io/cache-ignore-query-params  annotation on the Ingress:      ingress.kubernetes.io/cache-ignore-query-params: \"utm_* source_id\"  The value should be a list of UNIX globs ( * ,  ?  and  [...]  are supported);\nany matching query parameters will be ignored for caching.  To set a whitelist of URL parameters, set the ingress.kubernetes.io/cache-whitelist-query-params  annotation:      ingress.kubernetes.io/cache-whitelist-query-params: \"page view include_id_*\"  The format is the same as  cache-ignore-query-params , but the meaning is\nreversed: any URL parameter not matched will be ignored.  When using either of these annotations, you probably also want to set ingress.kubernetes.io/cache-sort-query-params: \"true\" , which will cause the\nURL parameters to be lexically sorted.  This means that a request for /?a=1&b=2  can be served a cached response for /?b=2&a=1 , improving cache hit\nrate across clients.  These annotations also change the query string sent to the application.  This is\nto ensure the application doesn't accidentally vary the page content based on a\nquery parameter that has been ignored for caching.",
            "title": "Caching and URL parameters"
        },
        {
            "location": "/caching/#removing-pages-from-the-cache",
            "text": "",
            "title": "Removing pages from the cache"
        },
        {
            "location": "/caching/#removing-individual-urls",
            "text": "You can purge individual URLs from the cache by sending an HTTP  PURGE  request\nto Traffic Server.  To make this easy to do from pods, create a Service for the\nTS pod.  The PURGE request should look like this:  PURGE http://www.mysite.com/mypage.html HTTP/1.0  Unfortunately, this doesn't work very well when multiple copies of TS are\nrunning, since there's no simple way for an application to retrieve the list of\nTS instances.  We plan to address this in a future release.",
            "title": "Removing individual URLs"
        },
        {
            "location": "/caching/#clearing-the-entire-cache",
            "text": "Occasionally, you might want to clear the cache for an entire domain, for\nexample if some boilerplate HTML has changed that affects all pages.  To do this,\nset the  ingress.kubernetes.io/cache-generation  annotation to a non-zero\ninteger.  This changes the cache generation for the Ingress; any objects cached\nwith a different generation are no longer visible, and have been effectively\nremoved from the cache.  Typically the cache generation would be set to the\ncurrent UNIX timestamp, although any non-zero integer will work.",
            "title": "Clearing the entire cache"
        },
        {
            "location": "/auth/",
            "text": "Authentication\n\n\nAuthentication restricts who can request a particular page.  Authenticatian can\nbe done using HTTP basic authentication, where the client sends a username and\npassword in the request; by IP address, where only certain IP addresses are\npermitted to request the content; or by a combination of both.\n\n\nPassword authentication\n\n\nTo enable password authentication, set the \ningress.kubernetes.io/auth-type\n\nannotation on the Ingress to \nbasic\n, and \ningress.kubernetes.io/auth-secret\n\nto the name of a secret which contains an htpasswd file as the \nauth\n key:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/auth-type: basic\n    ingress.kubernetes.io/auth-secret: mysecret\n\n\n\n\nYou can create the necessary secret from an existing htpasswd file with \nkubectl\n:\n\n\n$ kubectl create secret generic mysecret --from-file=auth=my-htpasswd\n\n\n\n\nOptionally, set \ningress.kubernetes.io/auth-realm\n to the basic authentication\nrealm, which is displayed in the password prompt by most browsers.\n\n\nMost common password hash schemes are supported, including DES, MD5 (\n$1$\n and\n\n$apr1$\n), bcrypt (\n$2[abxy]$\n), SHA-256 (\n$5$\n) and SHA-512 (\n$6$\n), and four\nRFC2307-style hashes: \n{PLAIN}\n, \n{SHA}\n, \n{SSHA}\n and \n{CRYPT}\n (the first\nthree of which are also supported by nginx).\n\n\nSecurity-wise, although the MD5 schemes are extremely weak as password hashes,\nthey are probably fine for any situation where htpasswd-based authentication is\nin use.  The primary security improvement in newer algorithms (e.g. bcrypt and\nSHA-2) is they are slower, which increases the time required to perform an\noffline brute force attack; however, this also increases the time required to\n\ncheck\n the password, which leads to unacceptable delays on typical HTML page\nloads.\n\n\nFor example, if you use a bcrypt configuration that takes 200ms to check one\nhash, and you load an HTML page with 20 assets, then you will spend 4 seconds\ndoing nothing but waiting for authentication.  If multiple users are loading\npages at the same time, then things will be even slower once you run out of\nCPUs.\n\n\nIf you need stronger password security than MD5, you should stop using HTTP\nbasic authentication and use another authentication method (like Cookie-based\nauthentication) instead.\n\n\nIP address authentication\n\n\nTo enable IP authentication, set the\n\ningress.kubernetes.io/whitelist-source-range\n annotation to a comma-delimited\nlist of IP addresses or networks, for example \n\"127.0.0.0/8,::1/128\"\n.\n\n\nWhen both IP-based and password-authentication are configured on the same\ningress, you can set the \ningress.kubernetes.io/auth-satisfy\n annotation to\neither \nany\n or \nall\n:\n\n\n\n\n\n\nany\n will permit the request if either the IP is present in\n  \nwhitelist-source-range\n or if the client provides valid basic authentication;\n  otherwise the request will be denied with HTTP 401 Unauthorized.\n\n\n\n\n\n\nall\n will permit the request if the client IP is present in\n  \nwhitelist-source-range\n \nand\n the client also provides valid basic\n  authentication.  If the client IP address is not in the address list, the\n  request will be denied with HTTP 403 Forbidden.  If the IP address is present\n  but the request did not contain valid basic authentication, the request will\n  be denied with HTTP 401 Unauthorized.\n\n\n\n\n\n\nTo prevent accidental misconfiguration, the default value is \nall\n.\n\n\nImportant\n: IP address authentication requires that Traffic Server knows the\noriginal IP address of the client making the request.  If TS is serving requests\ndirectly, or sits behind a transparent load balancer that preserves the client\nIP address (such as an Azure service, a GCE network load balancer, or Linux LVS\nin some configurations), then this will be the case; otherwise, it will see all\nrequests as coming from the load balancer's internal IP address, and\nauthentication will not be effective.  We plan to address this limitation in a\nfuture release, using either the \nX-Forwarded-For\n header field, or the\nso-called Proxy Protocol.\n\n\nScalability note: The IP list is implemented as a simple linked list, rather\nthan a more efficient data structure such as a radix tree.  This means that the\nlookup time, and consequently the overall request time, will increase linearly\nas the number of entries in the list increases.\n\n\nThis decision was made because a linked list is a simpler data structure, and\ntherefore performs better with a small number of entries even though performance\nis worse with a larger list.  This trade-off will only become noticeable if you\nhave hundreds or thousands of entries in the address list, which is very\nunlikely in real-world deployments.  (For one thing, it would be extremely\ncumbersome to manage such a large list as an annotation.)\n\n\nIf you require support for such a large number of addresses in a single Ingress,\nplease let us know via a Github issue.",
            "title": "Authentication"
        },
        {
            "location": "/auth/#authentication",
            "text": "Authentication restricts who can request a particular page.  Authenticatian can\nbe done using HTTP basic authentication, where the client sends a username and\npassword in the request; by IP address, where only certain IP addresses are\npermitted to request the content; or by a combination of both.",
            "title": "Authentication"
        },
        {
            "location": "/auth/#password-authentication",
            "text": "To enable password authentication, set the  ingress.kubernetes.io/auth-type \nannotation on the Ingress to  basic , and  ingress.kubernetes.io/auth-secret \nto the name of a secret which contains an htpasswd file as the  auth  key:  metadata:\n  annotations:\n    ingress.kubernetes.io/auth-type: basic\n    ingress.kubernetes.io/auth-secret: mysecret  You can create the necessary secret from an existing htpasswd file with  kubectl :  $ kubectl create secret generic mysecret --from-file=auth=my-htpasswd  Optionally, set  ingress.kubernetes.io/auth-realm  to the basic authentication\nrealm, which is displayed in the password prompt by most browsers.  Most common password hash schemes are supported, including DES, MD5 ( $1$  and $apr1$ ), bcrypt ( $2[abxy]$ ), SHA-256 ( $5$ ) and SHA-512 ( $6$ ), and four\nRFC2307-style hashes:  {PLAIN} ,  {SHA} ,  {SSHA}  and  {CRYPT}  (the first\nthree of which are also supported by nginx).  Security-wise, although the MD5 schemes are extremely weak as password hashes,\nthey are probably fine for any situation where htpasswd-based authentication is\nin use.  The primary security improvement in newer algorithms (e.g. bcrypt and\nSHA-2) is they are slower, which increases the time required to perform an\noffline brute force attack; however, this also increases the time required to check  the password, which leads to unacceptable delays on typical HTML page\nloads.  For example, if you use a bcrypt configuration that takes 200ms to check one\nhash, and you load an HTML page with 20 assets, then you will spend 4 seconds\ndoing nothing but waiting for authentication.  If multiple users are loading\npages at the same time, then things will be even slower once you run out of\nCPUs.  If you need stronger password security than MD5, you should stop using HTTP\nbasic authentication and use another authentication method (like Cookie-based\nauthentication) instead.",
            "title": "Password authentication"
        },
        {
            "location": "/auth/#ip-address-authentication",
            "text": "To enable IP authentication, set the ingress.kubernetes.io/whitelist-source-range  annotation to a comma-delimited\nlist of IP addresses or networks, for example  \"127.0.0.0/8,::1/128\" .  When both IP-based and password-authentication are configured on the same\ningress, you can set the  ingress.kubernetes.io/auth-satisfy  annotation to\neither  any  or  all :    any  will permit the request if either the IP is present in\n   whitelist-source-range  or if the client provides valid basic authentication;\n  otherwise the request will be denied with HTTP 401 Unauthorized.    all  will permit the request if the client IP is present in\n   whitelist-source-range   and  the client also provides valid basic\n  authentication.  If the client IP address is not in the address list, the\n  request will be denied with HTTP 403 Forbidden.  If the IP address is present\n  but the request did not contain valid basic authentication, the request will\n  be denied with HTTP 401 Unauthorized.    To prevent accidental misconfiguration, the default value is  all .  Important : IP address authentication requires that Traffic Server knows the\noriginal IP address of the client making the request.  If TS is serving requests\ndirectly, or sits behind a transparent load balancer that preserves the client\nIP address (such as an Azure service, a GCE network load balancer, or Linux LVS\nin some configurations), then this will be the case; otherwise, it will see all\nrequests as coming from the load balancer's internal IP address, and\nauthentication will not be effective.  We plan to address this limitation in a\nfuture release, using either the  X-Forwarded-For  header field, or the\nso-called Proxy Protocol.  Scalability note: The IP list is implemented as a simple linked list, rather\nthan a more efficient data structure such as a radix tree.  This means that the\nlookup time, and consequently the overall request time, will increase linearly\nas the number of entries in the list increases.  This decision was made because a linked list is a simpler data structure, and\ntherefore performs better with a small number of entries even though performance\nis worse with a larger list.  This trade-off will only become noticeable if you\nhave hundreds or thousands of entries in the address list, which is very\nunlikely in real-world deployments.  (For one thing, it would be extremely\ncumbersome to manage such a large list as an annotation.)  If you require support for such a large number of addresses in a single Ingress,\nplease let us know via a Github issue.",
            "title": "IP address authentication"
        },
        {
            "location": "/external/",
            "text": "Proxying to external services\n\n\nSometimes, you might want to proxy traffic to a service that doesn't run as a\nKubernetes pod.  This can be used to expose external services via an Ingress,\nand to allow the \nfollow-redirects\n annotation to access external resources.\n\n\nExternal proxying via IP address\n\n\nTo proxy requests to a particular IP address or a set of IP address, create a\n\nService\n resource without a selector, and create its associated \nEndpoints\n\nresource:\n\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n\n---\n\nkind: Endpoints\napiVersion: v1\nmetadata:\n  name: external-service\nsubsets:\n- addresses:\n  - ip: 1.2.3.4\n  ports:\n  - port: 80\n\n\n\n\nYou can now define an Ingress to route traffic to this service:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80\n\n\n\n\nTraffic Server will now route requests for \nhttp://external.example.com/\n to your\nexternal service at IP address \n1.2.3.4\n.\n\n\nExternal proxying via hostname\n\n\nTo proxy to an external hostname, create a \nService\n resource of type\n\nExternalName\n:\n\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName\n  externalName: my-external-backend.example.com\n\n\n\n\nYou do not need to configure an \nEndpoints\n resource as with an external IP\naddress.  Create an Ingress for this Service:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\n  annotations:\n    ingress.kubernetes.io/preserve-host: \"false\"\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80\n\n\n\n\nNow requests for \nhttp://external.example.com\n will be proxied to\n\nhttp://my-external-backend.example.com\n.\n\n\nWhen using an ExternalName Service, the \nservicePort\n must be an integer;\nnamed ports are not supported.\n\n\nIn most cases, you will want to set the \npreserve-host\n annotation to \n\"false\"\n\nso that the external service sees the hostname it's expecting, rather than the\nhostname in the client request.\n\n\nExternal proxying and TLS\n\n\nBy default, even if a request uses TLS, it will be proxied to the external\nbackend via HTTP.  To use TLS for the backend, set an annotation on the Ingress:\n\ningress.kubernetes.io/secure-backends: \"true\"\n.  This is not very useful for\nexternal IP addresses, because it's unlikely the backend will have a TLS\ncertificate for its IP address, but it will work well with \nExternalName\n\nservices.\n\n\nFor TLS to work, remember to set \nservicePort\n to \n443\n (or some other suitable\nvalue).",
            "title": "External proxying"
        },
        {
            "location": "/external/#proxying-to-external-services",
            "text": "Sometimes, you might want to proxy traffic to a service that doesn't run as a\nKubernetes pod.  This can be used to expose external services via an Ingress,\nand to allow the  follow-redirects  annotation to access external resources.",
            "title": "Proxying to external services"
        },
        {
            "location": "/external/#external-proxying-via-ip-address",
            "text": "To proxy requests to a particular IP address or a set of IP address, create a Service  resource without a selector, and create its associated  Endpoints \nresource:  kind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n\n---\n\nkind: Endpoints\napiVersion: v1\nmetadata:\n  name: external-service\nsubsets:\n- addresses:\n  - ip: 1.2.3.4\n  ports:\n  - port: 80  You can now define an Ingress to route traffic to this service:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80  Traffic Server will now route requests for  http://external.example.com/  to your\nexternal service at IP address  1.2.3.4 .",
            "title": "External proxying via IP address"
        },
        {
            "location": "/external/#external-proxying-via-hostname",
            "text": "To proxy to an external hostname, create a  Service  resource of type ExternalName :  kind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName\n  externalName: my-external-backend.example.com  You do not need to configure an  Endpoints  resource as with an external IP\naddress.  Create an Ingress for this Service:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\n  annotations:\n    ingress.kubernetes.io/preserve-host: \"false\"\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80  Now requests for  http://external.example.com  will be proxied to http://my-external-backend.example.com .  When using an ExternalName Service, the  servicePort  must be an integer;\nnamed ports are not supported.  In most cases, you will want to set the  preserve-host  annotation to  \"false\" \nso that the external service sees the hostname it's expecting, rather than the\nhostname in the client request.",
            "title": "External proxying via hostname"
        },
        {
            "location": "/external/#external-proxying-and-tls",
            "text": "By default, even if a request uses TLS, it will be proxied to the external\nbackend via HTTP.  To use TLS for the backend, set an annotation on the Ingress: ingress.kubernetes.io/secure-backends: \"true\" .  This is not very useful for\nexternal IP addresses, because it's unlikely the backend will have a TLS\ncertificate for its IP address, but it will work well with  ExternalName \nservices.  For TLS to work, remember to set  servicePort  to  443  (or some other suitable\nvalue).",
            "title": "External proxying and TLS"
        },
        {
            "location": "/tls/",
            "text": "Using TLS\n\n\nConfiguration\n\n\nTLS keys and certificates are taken from Kubernetes Secret resources according\nto the \ntls\n attribute of each Ingress resource.  See the\n\nIngress documentation\n\nfor details on how to configure TLS.\n\n\nTLS Server Name Indication support is required for TLS to work; clients without\nSNI support will receive a TLS negotiation error.  There is no default\ncertificate for non-SNI-capable clients.\n\n\nIf you don't want to use Kubernetes for TLS, set \ntls: false\n in\n\nkubernetes.config\n or set the \n$TS_TLS\n environment variable to \n\"false\"\n.\nYou will need to provide TLS configuration some other way, like\n\nssl_multicert.config\n or the \nssl-cert-loader\n plugin, or else terminate TLS\nbefore traffic reaches Traffic Server.\n\n\nRedirecting HTTP to HTTPS\n\n\nBy default, insecure HTTP requests to an Ingress which has TLS configured will\nbe redirected to HTTPS with an HTTP 301 response.  To disable this behaviour,\nset the \ningress.kubernetes.io/ssl-redirect\n annotation to \nfalse\n.\n\n\nTo force a redirect to HTTPS even when TLS is not configured on the Ingress, set\nthe \ningress.kubernetes.io/force-ssl-redirect\n annotation to \n\"true\"\n.  This\nwill not work unless you are offloading TLS termination in front of Traffic\nServer.\n\n\nConnecting to pods via HTTPS\n\n\nUsually, communication between Traffic Server and backends (e.g. pods) is via\ninsecure HTTP, even if the request was made over HTTPS.  To use HTTPS for\ncommunicate with the backend, set the \ningress.kubernetes.io/secure-backends\n\nannotation to \n\"true\"\n.  This is not very useful when the backend is a pod,\nbecause TS connects to the pod by its IP address, and it's extremely unlikely\nthe pod will have a TLS certificate for that IP address.  However, this can be\nuseful when using \nexternal proxying\n.\n\n\nA better method to secure traffic between Traffic Server and pods is to use a\nnetwork CNI plugin that supports encryption, such as Weave Net.\n\n\nHSTS\n\n\nTo enable HTTP Strict Transport Security (HSTS), set the\n\ningress.kubernetes.io/hsts-max-age\n annotation on the Ingress to the HSTS\nmax-age time in seconds.  To be useful, this should be set to at least six\nmonths (15768000 seconds), but you should start with a lower value and gradually\nincrease it.  Do not set it to a large value without testing it first, because,\nby design, it cannot be turned off for browsers that already saw the HSTS\nheader until the max-age expires.\n\n\nHSTS headers are per-hostname, not per-path.  Therefore, \nhsts-max-age\n can only\nbe set on the Ingress that includes the root path for a particular hostname\n(i.e., where the Ingress rule has no \npath\n attribute).\n\n\nTo apply HSTS to subdomains as well, set the\n\ningress.kubernetes.io/hsts-include-subdomains\n annotation.\n\n\nConfiguring the TLS cypher list\n\n\nYou cannot configure the cypher list on the Ingress level; this was judged to be\ntoo risky, as users are likely to set a cypher list and not keep it up to date\nwith changes in best practice.  (If you require this feature, please open a\n\nGithub issue\n.)\n\n\nTo configure the global cypher list, set \nproxy.config.ssl.server.cipher_suite\n\nin the TS \nrecords.config\n file to an OpenSSL cypher string, or set the\n\n$PROXY_CONFIG_SSL_SERVER_CIPHER_SUITE\n environment variable:\n\n\nPROXY_CONFIG_SSL_SERVER_CIPHER_SUITE=ECDH+AES:DH+AES:RSA+AES:!aNULL:!MD5:!DSS\n\n\n\n\nUsing kube-lego\n\n\nkube-lego\n is a Kubernetes controller\nthat automatically provisions TLS certificates using an ACME provider such as\nLet's Encrypt.  It is ideal for test or staging environments (or even production\nenvironments when domain-validated TLS certificates are sufficient), but it\ncurrently \ndoesn't support\n\nany Ingress controllers other than nginx and GCE.\n\n\nTo use the TS Ingress controller with kube-lego, you should configure kube-lego\nas if you were using the nginx Ingress controller, then tell TS to handle the\n\n\"nginx\"\n Ingress class, either by setting the environment variable\n\n$TS_INGRESS_CLASSES\n to \ntrafficserver nginx\n, or in \nkubernetes.config\n:\n\n\ningress_classes: trafficserver nginx",
            "title": "TLS"
        },
        {
            "location": "/tls/#using-tls",
            "text": "",
            "title": "Using TLS"
        },
        {
            "location": "/tls/#configuration",
            "text": "TLS keys and certificates are taken from Kubernetes Secret resources according\nto the  tls  attribute of each Ingress resource.  See the Ingress documentation \nfor details on how to configure TLS.  TLS Server Name Indication support is required for TLS to work; clients without\nSNI support will receive a TLS negotiation error.  There is no default\ncertificate for non-SNI-capable clients.  If you don't want to use Kubernetes for TLS, set  tls: false  in kubernetes.config  or set the  $TS_TLS  environment variable to  \"false\" .\nYou will need to provide TLS configuration some other way, like ssl_multicert.config  or the  ssl-cert-loader  plugin, or else terminate TLS\nbefore traffic reaches Traffic Server.",
            "title": "Configuration"
        },
        {
            "location": "/tls/#redirecting-http-to-https",
            "text": "By default, insecure HTTP requests to an Ingress which has TLS configured will\nbe redirected to HTTPS with an HTTP 301 response.  To disable this behaviour,\nset the  ingress.kubernetes.io/ssl-redirect  annotation to  false .  To force a redirect to HTTPS even when TLS is not configured on the Ingress, set\nthe  ingress.kubernetes.io/force-ssl-redirect  annotation to  \"true\" .  This\nwill not work unless you are offloading TLS termination in front of Traffic\nServer.",
            "title": "Redirecting HTTP to HTTPS"
        },
        {
            "location": "/tls/#connecting-to-pods-via-https",
            "text": "Usually, communication between Traffic Server and backends (e.g. pods) is via\ninsecure HTTP, even if the request was made over HTTPS.  To use HTTPS for\ncommunicate with the backend, set the  ingress.kubernetes.io/secure-backends \nannotation to  \"true\" .  This is not very useful when the backend is a pod,\nbecause TS connects to the pod by its IP address, and it's extremely unlikely\nthe pod will have a TLS certificate for that IP address.  However, this can be\nuseful when using  external proxying .  A better method to secure traffic between Traffic Server and pods is to use a\nnetwork CNI plugin that supports encryption, such as Weave Net.",
            "title": "Connecting to pods via HTTPS"
        },
        {
            "location": "/tls/#hsts",
            "text": "To enable HTTP Strict Transport Security (HSTS), set the ingress.kubernetes.io/hsts-max-age  annotation on the Ingress to the HSTS\nmax-age time in seconds.  To be useful, this should be set to at least six\nmonths (15768000 seconds), but you should start with a lower value and gradually\nincrease it.  Do not set it to a large value without testing it first, because,\nby design, it cannot be turned off for browsers that already saw the HSTS\nheader until the max-age expires.  HSTS headers are per-hostname, not per-path.  Therefore,  hsts-max-age  can only\nbe set on the Ingress that includes the root path for a particular hostname\n(i.e., where the Ingress rule has no  path  attribute).  To apply HSTS to subdomains as well, set the ingress.kubernetes.io/hsts-include-subdomains  annotation.",
            "title": "HSTS"
        },
        {
            "location": "/tls/#configuring-the-tls-cypher-list",
            "text": "You cannot configure the cypher list on the Ingress level; this was judged to be\ntoo risky, as users are likely to set a cypher list and not keep it up to date\nwith changes in best practice.  (If you require this feature, please open a Github issue .)  To configure the global cypher list, set  proxy.config.ssl.server.cipher_suite \nin the TS  records.config  file to an OpenSSL cypher string, or set the $PROXY_CONFIG_SSL_SERVER_CIPHER_SUITE  environment variable:  PROXY_CONFIG_SSL_SERVER_CIPHER_SUITE=ECDH+AES:DH+AES:RSA+AES:!aNULL:!MD5:!DSS",
            "title": "Configuring the TLS cypher list"
        },
        {
            "location": "/tls/#using-kube-lego",
            "text": "kube-lego  is a Kubernetes controller\nthat automatically provisions TLS certificates using an ACME provider such as\nLet's Encrypt.  It is ideal for test or staging environments (or even production\nenvironments when domain-validated TLS certificates are sufficient), but it\ncurrently  doesn't support \nany Ingress controllers other than nginx and GCE.  To use the TS Ingress controller with kube-lego, you should configure kube-lego\nas if you were using the nginx Ingress controller, then tell TS to handle the \"nginx\"  Ingress class, either by setting the environment variable $TS_INGRESS_CLASSES  to  trafficserver nginx , or in  kubernetes.config :  ingress_classes: trafficserver nginx",
            "title": "Using kube-lego"
        }
    ]
}