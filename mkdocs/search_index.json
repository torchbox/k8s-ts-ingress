{
    "docs": [
        {
            "location": "/",
            "text": "Traffic Server ingress controller\n\n\nWARNING: This is alpha code, do not use it in production.\n\n\nThis is a Kubernetes ingress controller plugin for\n\nApache Traffic Server\n, a high-performance,\nextensible HTTP proxy server (unrelated to Apache httpd).  The Ingress\ncontroller allows Traffic Server to act as an ingress controller for Kubernetes\nclusters, routing incoming requests to pods while providing TLS termination,\ncaching, ESI and other standard Traffic Server features.\n\n\nThe controller is provided as C source code and as a pre-built Docker image.\nIf you want to add Kubernetes support to an existing instance of TS, you should\nbuild the plugin from source.  If you want to deploy TS inside a Kubernetes\ncluster, you can use the pre-built Docker image.\n\n\nQuick start\n\n\nTo deploy the image on an existing Kubernetes 1.6 (or later) cluster:\n\n\n$ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-rbac.yaml | kubectl apply -f -\n$ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-deployment.yaml | kubectl apply -f -\n\n\n\n\n(If you're using 1.5 or earlier, you can still use \nexample-deployment.yaml\n,\nbut if you need RBAC support you will need to convert \nexample-rbac.yaml\n to use\nthe old alpha RBAC API.)\n\n\nThis will start two copies of Traffic Server, each with an emptyDir volume for\ncache storage, listening on node ports 30080 (http) and 30443 (https).   You can\nconfigure an external load balancer of some sort to route incoming traffic to\nthose ports, or use Kubernetes'\n\nkeepalived-vip\n\nto manage a virtual IP address on your cluster.\n\n\nFor more detailed installation instructions, see the documentation for\n\nbuilding from source\n or \nDeploying on Kubernetes\n.\n\n\nFeatures\n\n\nThe controller provides the following features:\n\n\n\n\nFull support for Ingress resources, including many annotations used by other\n  controller implementations;\n\n\nHTTP/2;\n\n\nWebSockets;\n\n\nTLS termination, configured in the Ingress resource using Kubernetes Secrets;\n\n\nCaching of responses, controlled by \nCache-Control\n or \nExpires\n headers,\n  including support for alternatives (the HTTP \nVary\n header field), removal of\n  individual pages from the cache (\nPURGE\n), and fast clearing of the entire\n  cache;\n\n\nAuthorization using HTTP Basic authentication or client IP address;\n\n\nProxying to external (non-Kubernetes) services using Ingress resources;\n\n\nESI (Edge-Side Includes).\n\n\n\n\nMore features are planned for future releases.  If you would like to see a\nparticular feature supported, please \nopen a Github issue\n.\n\n\nRelease history\n\n\n\n\n1.0.0-alpha5:\n\n\nIncompatible change: The \ningress.torchbox.com/auth-address-list\n\n    annotation was renamed to \ningress.kubernetes.io/whitelist-source-range\n,\n    and is now comma-delimited, for compatibility with other Ingress\n    controllers.\n\n\nFeature: Support Ingress classes.\n\n\nFeature: The X-Forwarded-Proto header is now (optionally) sent to the\n    backend.\n\n\nFeature: The \ncache-whitelist-params\n and \ncache-ignore-params\n\n    annotations were implemented.\n\n\nFeature: The \ntls_verify\n configuration option was added.\n\n\nImprovement: The API server connection code was reimplemented using cURL,\n    making it more reliable and featureful.\n\n\nBug fix: TLS redirects with an empty URL path could crash.\n\n\nBug fix: TLS secret handling could leak memory.\n\n\nBug fix: with some combinations of Traffic Server and OpenSSL versions,\n    TLS certificates might not be loaded correctly.  Use the new\n    TS_SSL_CERT_HOOK hook to ensure this works properly in all cases.\n\n\nBug fix: An Endpoints with more than one port or address could be parsed\n    incorrectly or cause a crash.\n\n\n\n\n\n\n1.0.0-alpha4:\n\n\nDo not return a client error if the requested host or path was not\n  found, to allow use with other plugins like healthchecks.\n\n\n\n\n\n\n1.0.0-alpha3:\n\n\nGreatly improved unit test coverage.\n\n\nSeveral minor bugs fixed.\n\n\nSupport configuration via environment variables.\n\n\n\n\n\n\n1.0.0-alpha2: Implement IP address authentication.\n\n\n1.0.0-alpha1: Initial release.\n\n\n\n\nLicense and credits\n\n\nThis plugin was developed by Felicity Tarnell (ft@le-Fay.ORG) for\n\nTorchbox Ltd.\n.  Copyright (c) 2016-2017 Torchbox Ltd.\n\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely. This software is provided 'as-is', without any express or implied\nwarranty.\n\n\n\n\ncrypt_bf.c\n was written by Solar Designer, and is released into the public\ndomain.\n\n\ncrypt_des.c\n is copyright (c) 1989, 1993 The Regents of the University of\nCalifornia, based on code written by Tom Truscott.\n\n\nstrmatch.c\n is copyright (c) 1989, 1993, 1994 The Regents of the University\nof California, based on code written by Guido van Rossum.\n\n\ncrypt_md5.c\n was written by Poul-Henning Kamp, and is released under the\n\"beer-ware\" license.\n\n\ncrypt_sha256.c\n and \ncrypt_sha512.c\n were written by Ulrich Drepper, and are\nreleased into the public domain.\n\n\nhash.c\n contains code written by Landon Curt Noll, which is released into the\npublic domain.\n\n\nbase64.c\n is copyright (c) 2011-2017 Felicity Tarnell.",
            "title": "Home"
        },
        {
            "location": "/#traffic-server-ingress-controller",
            "text": "WARNING: This is alpha code, do not use it in production.  This is a Kubernetes ingress controller plugin for Apache Traffic Server , a high-performance,\nextensible HTTP proxy server (unrelated to Apache httpd).  The Ingress\ncontroller allows Traffic Server to act as an ingress controller for Kubernetes\nclusters, routing incoming requests to pods while providing TLS termination,\ncaching, ESI and other standard Traffic Server features.  The controller is provided as C source code and as a pre-built Docker image.\nIf you want to add Kubernetes support to an existing instance of TS, you should\nbuild the plugin from source.  If you want to deploy TS inside a Kubernetes\ncluster, you can use the pre-built Docker image.",
            "title": "Traffic Server ingress controller"
        },
        {
            "location": "/#quick-start",
            "text": "To deploy the image on an existing Kubernetes 1.6 (or later) cluster:  $ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-rbac.yaml | kubectl apply -f -\n$ curl -L https://raw.githubusercontent.com/torchbox/k8s-ts-ingress/master/example-deployment.yaml | kubectl apply -f -  (If you're using 1.5 or earlier, you can still use  example-deployment.yaml ,\nbut if you need RBAC support you will need to convert  example-rbac.yaml  to use\nthe old alpha RBAC API.)  This will start two copies of Traffic Server, each with an emptyDir volume for\ncache storage, listening on node ports 30080 (http) and 30443 (https).   You can\nconfigure an external load balancer of some sort to route incoming traffic to\nthose ports, or use Kubernetes' keepalived-vip \nto manage a virtual IP address on your cluster.  For more detailed installation instructions, see the documentation for building from source  or  Deploying on Kubernetes .",
            "title": "Quick start"
        },
        {
            "location": "/#features",
            "text": "The controller provides the following features:   Full support for Ingress resources, including many annotations used by other\n  controller implementations;  HTTP/2;  WebSockets;  TLS termination, configured in the Ingress resource using Kubernetes Secrets;  Caching of responses, controlled by  Cache-Control  or  Expires  headers,\n  including support for alternatives (the HTTP  Vary  header field), removal of\n  individual pages from the cache ( PURGE ), and fast clearing of the entire\n  cache;  Authorization using HTTP Basic authentication or client IP address;  Proxying to external (non-Kubernetes) services using Ingress resources;  ESI (Edge-Side Includes).   More features are planned for future releases.  If you would like to see a\nparticular feature supported, please  open a Github issue .",
            "title": "Features"
        },
        {
            "location": "/#release-history",
            "text": "1.0.0-alpha5:  Incompatible change: The  ingress.torchbox.com/auth-address-list \n    annotation was renamed to  ingress.kubernetes.io/whitelist-source-range ,\n    and is now comma-delimited, for compatibility with other Ingress\n    controllers.  Feature: Support Ingress classes.  Feature: The X-Forwarded-Proto header is now (optionally) sent to the\n    backend.  Feature: The  cache-whitelist-params  and  cache-ignore-params \n    annotations were implemented.  Feature: The  tls_verify  configuration option was added.  Improvement: The API server connection code was reimplemented using cURL,\n    making it more reliable and featureful.  Bug fix: TLS redirects with an empty URL path could crash.  Bug fix: TLS secret handling could leak memory.  Bug fix: with some combinations of Traffic Server and OpenSSL versions,\n    TLS certificates might not be loaded correctly.  Use the new\n    TS_SSL_CERT_HOOK hook to ensure this works properly in all cases.  Bug fix: An Endpoints with more than one port or address could be parsed\n    incorrectly or cause a crash.    1.0.0-alpha4:  Do not return a client error if the requested host or path was not\n  found, to allow use with other plugins like healthchecks.    1.0.0-alpha3:  Greatly improved unit test coverage.  Several minor bugs fixed.  Support configuration via environment variables.    1.0.0-alpha2: Implement IP address authentication.  1.0.0-alpha1: Initial release.",
            "title": "Release history"
        },
        {
            "location": "/#license-and-credits",
            "text": "This plugin was developed by Felicity Tarnell (ft@le-Fay.ORG) for Torchbox Ltd. .  Copyright (c) 2016-2017 Torchbox Ltd.  Permission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely. This software is provided 'as-is', without any express or implied\nwarranty.   crypt_bf.c  was written by Solar Designer, and is released into the public\ndomain.  crypt_des.c  is copyright (c) 1989, 1993 The Regents of the University of\nCalifornia, based on code written by Tom Truscott.  strmatch.c  is copyright (c) 1989, 1993, 1994 The Regents of the University\nof California, based on code written by Guido van Rossum.  crypt_md5.c  was written by Poul-Henning Kamp, and is released under the\n\"beer-ware\" license.  crypt_sha256.c  and  crypt_sha512.c  were written by Ulrich Drepper, and are\nreleased into the public domain.  hash.c  contains code written by Landon Curt Noll, which is released into the\npublic domain.  base64.c  is copyright (c) 2011-2017 Felicity Tarnell.",
            "title": "License and credits"
        },
        {
            "location": "/source/",
            "text": "Installing the plugin from source\n\n\nIf you want to integrate Kubernetes with an existing Traffic Server installation,\nyou can build the plugin from source.  If you're planning to deploy the plugin\ninside a Kubernetes cluster, you should read \nUsing the Docker image\n\ninstead.\n\n\nRequirements\n\n\nThe following are required to build:\n\n\n\n\nTraffic Server 7.0 or later (including development headers).  Older versions\n  might work, but are not tested or supported.\n\n\nA working C99 compiler and \nmake\n utility.\n\n\njson-c library\n\n\ncURL library\n\n\nOpenSSL (or a compatible TLS library, e.g. LibreSSL)\n\n\n\n\nBuilding\n\n\nTo build and install the plugin:\n\n\n$ autoreconf -if            # only if building from a git checkout\n$ ./configure [--with-tsxs=/path/to/trafficserver/bin/tsxs]\n$ make\n$ make install\n\n\n\n\nThis will put \nkubernetes.so\n in your Traffic Server plugins directory.  Edit\n\nplugin.config\n to tell Traffic Server to load the plugin.\n\n\nConfiguration\n\n\nIf Traffic Server is not running inside the cluster, you will need to provide a\nconfiguration file.  Copy \nkubernetes.config.example\n to the Traffic Server\nconfiguration directory, rename it to \nkubernetes.config\n, and edit it as\nappropriate.\n\n\nYou will need to tell the plugin to load the configuration file in \nplugin.config\n:\n\n\nkubernetes.so kubernetes.conf\n\n\n\n\nIf TS is running inside the cluster, it will pick up its service account details\nautomatically and the configuration file is not required, but you will need to\nensure it has access to the resources it needs to run.  If you're using RBAC\nfor authorization, see \nrbac.yaml\n for an example RBAC configuration.",
            "title": "Installing from source"
        },
        {
            "location": "/source/#installing-the-plugin-from-source",
            "text": "If you want to integrate Kubernetes with an existing Traffic Server installation,\nyou can build the plugin from source.  If you're planning to deploy the plugin\ninside a Kubernetes cluster, you should read  Using the Docker image \ninstead.",
            "title": "Installing the plugin from source"
        },
        {
            "location": "/source/#requirements",
            "text": "The following are required to build:   Traffic Server 7.0 or later (including development headers).  Older versions\n  might work, but are not tested or supported.  A working C99 compiler and  make  utility.  json-c library  cURL library  OpenSSL (or a compatible TLS library, e.g. LibreSSL)",
            "title": "Requirements"
        },
        {
            "location": "/source/#building",
            "text": "To build and install the plugin:  $ autoreconf -if            # only if building from a git checkout\n$ ./configure [--with-tsxs=/path/to/trafficserver/bin/tsxs]\n$ make\n$ make install  This will put  kubernetes.so  in your Traffic Server plugins directory.  Edit plugin.config  to tell Traffic Server to load the plugin.",
            "title": "Building"
        },
        {
            "location": "/source/#configuration",
            "text": "If Traffic Server is not running inside the cluster, you will need to provide a\nconfiguration file.  Copy  kubernetes.config.example  to the Traffic Server\nconfiguration directory, rename it to  kubernetes.config , and edit it as\nappropriate.  You will need to tell the plugin to load the configuration file in  plugin.config :  kubernetes.so kubernetes.conf  If TS is running inside the cluster, it will pick up its service account details\nautomatically and the configuration file is not required, but you will need to\nensure it has access to the resources it needs to run.  If you're using RBAC\nfor authorization, see  rbac.yaml  for an example RBAC configuration.",
            "title": "Configuration"
        },
        {
            "location": "/docker/",
            "text": "Using the Docker image on Kubernetes\n\n\nDeployment\n\n\nWe provide two examples Kubernetes deployments for the TS ingress controller:\n\n\n\n\nexample-daemonset.yaml\n uses a DaemonSet, with an example of using node\n  taints and affinity to run the controller only on master nodes, and exposes\n  TS using a hostPort;\n\n\nexample-deployment.yaml\n uses a Deployment, with a nodePort Service used to\n  expose TS.\n\n\n\n\nYou will probably want to read and edit one of these files before using it.\n\n\nUnfortunately, there are many different ways to expose an Ingress controller on\nKubernetes, and we can't document every possible variation, so you will need to\ndecide what method is best for your cluster.\n\n\nRuntime configuration\n\n\nMost Traffic Server configuration (i.e., \nrecords.config\n entries) can be\nchanged using environment variables; see the\n\nTraffic Server Documentation\n.\n\n\nThe TS Docker image provides one additional environment variable:\n\n\n\n\nTS_CACHE_SIZE\n: Size of the on-disk cache file to create, in megabytes.\n\n\n\n\nThe cache file will be created automatically on startup if it doesn't exist.\n\n\nCache storage\n\n\nThe example deployment resources use an \nemptyDir\n for cache storage.  This\nmeans the cache will persist across node reboots, but will we cleared if the\npod is move to a different node, or if it's upgraded (which deletes the old pod).\n\n\nFor persistent cache storage, mount a volume on \n/var/lib/trafficserver\n. \nHowever, be aware that only one instance of TS can access the cache at once.  If\nyou are running multiple copies, you will need to create a separate PV for each\ninstance (perhaps by using a StatefulSet instead of a DaemonSet).",
            "title": "Using the Docker Image"
        },
        {
            "location": "/docker/#using-the-docker-image-on-kubernetes",
            "text": "",
            "title": "Using the Docker image on Kubernetes"
        },
        {
            "location": "/docker/#deployment",
            "text": "We provide two examples Kubernetes deployments for the TS ingress controller:   example-daemonset.yaml  uses a DaemonSet, with an example of using node\n  taints and affinity to run the controller only on master nodes, and exposes\n  TS using a hostPort;  example-deployment.yaml  uses a Deployment, with a nodePort Service used to\n  expose TS.   You will probably want to read and edit one of these files before using it.  Unfortunately, there are many different ways to expose an Ingress controller on\nKubernetes, and we can't document every possible variation, so you will need to\ndecide what method is best for your cluster.",
            "title": "Deployment"
        },
        {
            "location": "/docker/#runtime-configuration",
            "text": "Most Traffic Server configuration (i.e.,  records.config  entries) can be\nchanged using environment variables; see the Traffic Server Documentation .  The TS Docker image provides one additional environment variable:   TS_CACHE_SIZE : Size of the on-disk cache file to create, in megabytes.   The cache file will be created automatically on startup if it doesn't exist.",
            "title": "Runtime configuration"
        },
        {
            "location": "/docker/#cache-storage",
            "text": "The example deployment resources use an  emptyDir  for cache storage.  This\nmeans the cache will persist across node reboots, but will we cleared if the\npod is move to a different node, or if it's upgraded (which deletes the old pod).  For persistent cache storage, mount a volume on  /var/lib/trafficserver . \nHowever, be aware that only one instance of TS can access the cache at once.  If\nyou are running multiple copies, you will need to create a separate PV for each\ninstance (perhaps by using a StatefulSet instead of a DaemonSet).",
            "title": "Cache storage"
        },
        {
            "location": "/classes/",
            "text": "Using multiple Ingress controllers\n\n\nIf you want to deploy more than one Ingress controller inside a cluster (for\nexample, to test the TS Ingress controller before deploying it properly), you\nwill need to use Ingress classes to control which resources should be handled\nby which controller.\n\n\nThe Ingress class is set as an annotation on the resource:\n\n\nmetadata:\n  annotations:\n    kubernetes.io/ingress.class: \"trafficserver\"\n\n\n\n\nThe TS Ingress controller will handle any Ingress resource which does not have\nan Ingress class set, or where the Ingress class is set to \"trafficserver\".\n\n\nTo change the Ingress classes that TS will handle, set \ningress_classes\n in\n\nkubernetes.config\n (or the \n$TS_INGRESS_CLASSES\n environment variable) to a\nwhitespace-separate list of values, e.g. \n\"trafficserver ts-staging\"\n.  This\ncan be used to run multiple copies of the TS Ingress controller in one cluster.\nIf you do this, the \ntrafficserver\n class will not be handled unless you\nexplicitly include it in the list.\n\n\nFor more information, see\n\nUsing Multiple Ingress Controller\n\nin the Kubernetes documentation.",
            "title": "Using multiple Ingress controllers"
        },
        {
            "location": "/classes/#using-multiple-ingress-controllers",
            "text": "If you want to deploy more than one Ingress controller inside a cluster (for\nexample, to test the TS Ingress controller before deploying it properly), you\nwill need to use Ingress classes to control which resources should be handled\nby which controller.  The Ingress class is set as an annotation on the resource:  metadata:\n  annotations:\n    kubernetes.io/ingress.class: \"trafficserver\"  The TS Ingress controller will handle any Ingress resource which does not have\nan Ingress class set, or where the Ingress class is set to \"trafficserver\".  To change the Ingress classes that TS will handle, set  ingress_classes  in kubernetes.config  (or the  $TS_INGRESS_CLASSES  environment variable) to a\nwhitespace-separate list of values, e.g.  \"trafficserver ts-staging\" .  This\ncan be used to run multiple copies of the TS Ingress controller in one cluster.\nIf you do this, the  trafficserver  class will not be handled unless you\nexplicitly include it in the list.  For more information, see Using Multiple Ingress Controller \nin the Kubernetes documentation.",
            "title": "Using multiple Ingress controllers"
        },
        {
            "location": "/annotations/",
            "text": "Ingress annotations\n\n\nThe behaviour of an Ingress can be configured by setting annotations on the\nIngress resource, e.g.:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/rewrite-target: '/myapp'\n\n\n\n\nAnnotations whose names with \ningress.kubernetes.io\n are standard annotations\nsupported by most Ingress controllers; those beginning with\n\ningress.torchbox.com\n are specific to the Traffic Server Ingress controller.\n\n\n\n\n\n\ningress.kubernetes.io/rewrite-target\n: if set to a string, the portion of the\n  request path matched by the Ingress \npath\n attribute will be replaced with\n  this string.  This has no effect on an Ingress without a \npath\n set.\n\n\n\n\n\n\ningress.kubernetes.io/app-root\n: if set to a path prefix, and the request URI\n  does not begin with that prefix, then a redirect will be returned to this\n  path.  This can be used for applications which sit in a subdirectory rather\n  than at the root.\n\n\n\n\n\n\ningress.torchbox.com/follow-redirects\n: if \n\"true\"\n, Traffic Server will\n  follow 3xx redirect responses and serve the final response to the client.\n  If the redirect destination is cached, it will be cached with the cache key\n  of the original request.  Redirects will only be followed to other Ingress\n  resources, not to arbitrary destinations (but see below about proxying to\n  external resources).\n\n\n\n\n\n\ningress.torchbox.com/preserve-host\n: if \n\"false\"\n, set the \nHost\n header\n  in the request to the backend name (e.g., the pod name), instead of the\n  original request host.",
            "title": "Annotations"
        },
        {
            "location": "/annotations/#ingress-annotations",
            "text": "The behaviour of an Ingress can be configured by setting annotations on the\nIngress resource, e.g.:  metadata:\n  annotations:\n    ingress.kubernetes.io/rewrite-target: '/myapp'  Annotations whose names with  ingress.kubernetes.io  are standard annotations\nsupported by most Ingress controllers; those beginning with ingress.torchbox.com  are specific to the Traffic Server Ingress controller.    ingress.kubernetes.io/rewrite-target : if set to a string, the portion of the\n  request path matched by the Ingress  path  attribute will be replaced with\n  this string.  This has no effect on an Ingress without a  path  set.    ingress.kubernetes.io/app-root : if set to a path prefix, and the request URI\n  does not begin with that prefix, then a redirect will be returned to this\n  path.  This can be used for applications which sit in a subdirectory rather\n  than at the root.    ingress.torchbox.com/follow-redirects : if  \"true\" , Traffic Server will\n  follow 3xx redirect responses and serve the final response to the client.\n  If the redirect destination is cached, it will be cached with the cache key\n  of the original request.  Redirects will only be followed to other Ingress\n  resources, not to arbitrary destinations (but see below about proxying to\n  external resources).    ingress.torchbox.com/preserve-host : if  \"false\" , set the  Host  header\n  in the request to the backend name (e.g., the pod name), instead of the\n  original request host.",
            "title": "Ingress annotations"
        },
        {
            "location": "/caching/",
            "text": "Using HTTP caching\n\n\nTraffic Server can cache HTTP and HTTPS responses from an application to improve\npage load speed.  On a site which serves a large amount of infrequently\nchanging pages to anonymous users, caching can provide a significant improvement\nto both performance and page load times.  It's not uncommon to see caching\nimprove a site's capacity from tens of requests per second to tens of thousands\nof requests per second, without using any additional resources (except for\nbandwidth, of course).\n\n\nConfiguring caching\n\n\nCaching is enabled on Ingress resources by default.  To indicate that a response\nis to be cached, your application should send a \nCache-Control\n header field in\nthe response:\n\n\nHTTP/1.1 200 OK\nCache-Control: public, max-age=3600\nContent-Type: text/html; charset=UTF-8\n...\n\n\n\n\nLike most HTTP header fields, this is a comma-separated list of values.  \npublic\n\nindicates that the page content does not contain private data (meaning it should\nbe cached by multi-user proxies like Traffic Server), and \nmax-age\n indicates how\nlong it should be cached for; in this case, 3600 seconds or one hour.\n\n\nAs an alternative to \nCache-Control\n, your application can send an \nExpires\n\nheader field containing a timestamp; the page will be cached until the expiry\ntime is reached.  \nExpires\n is not recommended for new applications, since\n\nCache-Control\n is more flexible and has better defined semantics.\n\n\nDisabling caching\n\n\nTo disable caching entirely on an Ingress, even if it sends \nCache-Control\n or\n\nExpires\n header fields, use the \ningress.kubernetes.io/cache-enable\n annotation:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"\n\n\n\n\nIf only some paths should have caching disabled, you can create another Ingress\nresource with \npath\n set to that path, and set the annotation on that Ingress.\n\n\nIf you only want to prevent certain pages from being cached, you can indicate\nthis using \nCache-Control\n:\n\n\nHTTP/1.1 200 OK\nCache-Control: no-cache, no-store\n\n\n\n\nYou should generally do this for any personalised pages, e.g. pages served to\nlogged-in users, or pages containing a \nSet-Cookie\n header field.  By default,\nTS will not use the cache for requests containing a \nCookie\n header field or\ncache responses containing a \nSet-Cookie\n field, but it's better to be explicit.\n\n\nCaching and URL parameters\n\n\nWhen a page is cached, its URL parameters are stored in the cache to ensure that\na request with different URL parameters returns the correct content.  For\nexample, the URL:\n\n\nhttp://www.mysite.com/listings/?page=1\n\n\n\n\nwill be cached differently from the URL:\n\n\nhttp://www.mysite.com/listings/?page=2\n\n\n\n\nUsually this is what you want and no additional configuration is required.\nHowever, sometimes clients may request pages with additional URL parameters\nwhich do not affect page content.  A good example of this is marketing tracking\nparameters like \nutm_medium\n which are used by JavaScript on the page to\nidentify traffic sources, but do not affect the page content at all.  Because\nthese URL parameters do not affect page content, they should not be considered\nwhen caching.  (The JavaScript tracking code will run anyway, so no data is\nlost.)\n\n\nThere are two approaches to configuring this: either you can set a list of URL\nparameters which should be ignored when caching (which is the safest method),\nor you can set a whitelist of parameters, where any parameters not in the\nlist will be ignored.\n\n\nTo exclude a set of parameters from caching, set the\n\ningress.kubernetes.io/cache-ignore-query-params\n annotation on the Ingress:\n\n\n    ingress.kubernetes.io/cache-ignore-query-params: \"utm_* source_id\"\n\n\n\n\nThe value should be a list of UNIX globs (\n*\n, \n?\n and \n[...]\n are supported);\nany matching query parameters will be ignored for caching.\n\n\nTo set a whitelist of URL parameters, set the\n\ningress.kubernetes.io/cache-whitelist-query-params\n annotation:\n\n\n    ingress.kubernetes.io/cache-whitelist-query-params: \"page view include_id_*\"\n\n\n\n\nThe format is the same as \ncache-ignore-query-params\n, but the meaning is\nreversed: any URL parameter not matched will be ignored.\n\n\nWhen using either of these annotations, you probably also want to set\n\ningress.kubernetes.io/cache-sort-query-params: \"true\"\n, which will cause the\nURL parameters to be lexically sorted.  These means that a request for \n/?a=1&b=2\n\nwill be cached the same as a request for \n/?b=2&a=1\n, improving cache hit rate\nacross clients.\n\n\nThese annotations also change the query string sent to the application.  This is\nto ensure the application doesn't accidentally vary the page content based on a\nquery parameter that has been ignored for caching.\n\n\nRemoving pages from the cache\n\n\nRemoving individual URLs\n\n\nYou can purge individual URLs from the cache by sending an HTTP \nPURGE\n request\nto Traffic Server.  To make this easy to do from pods, create a Service for the\nTS pod.  The PURGE request should look like this:\n\n\nPURGE http://www.mysite.com/mypage.html HTTP/1.0\n\n\n\n\nUnfortunately, this doesn't work very well when multiple copies of TS are\nrunning, since there's no simple way for an application to retrieve the list of\nTS instances.  We plan to address this in a future release.\n\n\nClearing the entire cache\n\n\nOccasionally, you might want to clear the cache for an entire domain, for\nexample if some boilerplate HTML has changed that affects all pages.  To do this,\nset the \ningress.kubernetes.io/cache-generation\n annotation to a non-zero\ninteger.  This changes the cache generation for the Ingress; any objects cached\nwith a different generation are no longer visible, and have been effectively\nremoved from the cache.  Typically the cache generation would be set to the\ncurrent UNIX timestamp, although any non-zero integer will work.",
            "title": "Caching"
        },
        {
            "location": "/caching/#using-http-caching",
            "text": "Traffic Server can cache HTTP and HTTPS responses from an application to improve\npage load speed.  On a site which serves a large amount of infrequently\nchanging pages to anonymous users, caching can provide a significant improvement\nto both performance and page load times.  It's not uncommon to see caching\nimprove a site's capacity from tens of requests per second to tens of thousands\nof requests per second, without using any additional resources (except for\nbandwidth, of course).",
            "title": "Using HTTP caching"
        },
        {
            "location": "/caching/#configuring-caching",
            "text": "Caching is enabled on Ingress resources by default.  To indicate that a response\nis to be cached, your application should send a  Cache-Control  header field in\nthe response:  HTTP/1.1 200 OK\nCache-Control: public, max-age=3600\nContent-Type: text/html; charset=UTF-8\n...  Like most HTTP header fields, this is a comma-separated list of values.   public \nindicates that the page content does not contain private data (meaning it should\nbe cached by multi-user proxies like Traffic Server), and  max-age  indicates how\nlong it should be cached for; in this case, 3600 seconds or one hour.  As an alternative to  Cache-Control , your application can send an  Expires \nheader field containing a timestamp; the page will be cached until the expiry\ntime is reached.   Expires  is not recommended for new applications, since Cache-Control  is more flexible and has better defined semantics.",
            "title": "Configuring caching"
        },
        {
            "location": "/caching/#disabling-caching",
            "text": "To disable caching entirely on an Ingress, even if it sends  Cache-Control  or Expires  header fields, use the  ingress.kubernetes.io/cache-enable  annotation:  metadata:\n  annotations:\n    ingress.kubernetes.io/cache-enable: \"false\"  If only some paths should have caching disabled, you can create another Ingress\nresource with  path  set to that path, and set the annotation on that Ingress.  If you only want to prevent certain pages from being cached, you can indicate\nthis using  Cache-Control :  HTTP/1.1 200 OK\nCache-Control: no-cache, no-store  You should generally do this for any personalised pages, e.g. pages served to\nlogged-in users, or pages containing a  Set-Cookie  header field.  By default,\nTS will not use the cache for requests containing a  Cookie  header field or\ncache responses containing a  Set-Cookie  field, but it's better to be explicit.",
            "title": "Disabling caching"
        },
        {
            "location": "/caching/#caching-and-url-parameters",
            "text": "When a page is cached, its URL parameters are stored in the cache to ensure that\na request with different URL parameters returns the correct content.  For\nexample, the URL:  http://www.mysite.com/listings/?page=1  will be cached differently from the URL:  http://www.mysite.com/listings/?page=2  Usually this is what you want and no additional configuration is required.\nHowever, sometimes clients may request pages with additional URL parameters\nwhich do not affect page content.  A good example of this is marketing tracking\nparameters like  utm_medium  which are used by JavaScript on the page to\nidentify traffic sources, but do not affect the page content at all.  Because\nthese URL parameters do not affect page content, they should not be considered\nwhen caching.  (The JavaScript tracking code will run anyway, so no data is\nlost.)  There are two approaches to configuring this: either you can set a list of URL\nparameters which should be ignored when caching (which is the safest method),\nor you can set a whitelist of parameters, where any parameters not in the\nlist will be ignored.  To exclude a set of parameters from caching, set the ingress.kubernetes.io/cache-ignore-query-params  annotation on the Ingress:      ingress.kubernetes.io/cache-ignore-query-params: \"utm_* source_id\"  The value should be a list of UNIX globs ( * ,  ?  and  [...]  are supported);\nany matching query parameters will be ignored for caching.  To set a whitelist of URL parameters, set the ingress.kubernetes.io/cache-whitelist-query-params  annotation:      ingress.kubernetes.io/cache-whitelist-query-params: \"page view include_id_*\"  The format is the same as  cache-ignore-query-params , but the meaning is\nreversed: any URL parameter not matched will be ignored.  When using either of these annotations, you probably also want to set ingress.kubernetes.io/cache-sort-query-params: \"true\" , which will cause the\nURL parameters to be lexically sorted.  These means that a request for  /?a=1&b=2 \nwill be cached the same as a request for  /?b=2&a=1 , improving cache hit rate\nacross clients.  These annotations also change the query string sent to the application.  This is\nto ensure the application doesn't accidentally vary the page content based on a\nquery parameter that has been ignored for caching.",
            "title": "Caching and URL parameters"
        },
        {
            "location": "/caching/#removing-pages-from-the-cache",
            "text": "",
            "title": "Removing pages from the cache"
        },
        {
            "location": "/caching/#removing-individual-urls",
            "text": "You can purge individual URLs from the cache by sending an HTTP  PURGE  request\nto Traffic Server.  To make this easy to do from pods, create a Service for the\nTS pod.  The PURGE request should look like this:  PURGE http://www.mysite.com/mypage.html HTTP/1.0  Unfortunately, this doesn't work very well when multiple copies of TS are\nrunning, since there's no simple way for an application to retrieve the list of\nTS instances.  We plan to address this in a future release.",
            "title": "Removing individual URLs"
        },
        {
            "location": "/caching/#clearing-the-entire-cache",
            "text": "Occasionally, you might want to clear the cache for an entire domain, for\nexample if some boilerplate HTML has changed that affects all pages.  To do this,\nset the  ingress.kubernetes.io/cache-generation  annotation to a non-zero\ninteger.  This changes the cache generation for the Ingress; any objects cached\nwith a different generation are no longer visible, and have been effectively\nremoved from the cache.  Typically the cache generation would be set to the\ncurrent UNIX timestamp, although any non-zero integer will work.",
            "title": "Clearing the entire cache"
        },
        {
            "location": "/auth/",
            "text": "Authentication\n\n\nAuthentication restricts who can request a particular page.  Authenticatian can\nbe done using HTTP basic authentication, where the client sends a username and\npassword in the request; by IP address, where only certain IP addresses are\npermitted to request the content; or by a combination of both.\n\n\nPassword authentication\n\n\nTo enable password authentication, set the \ningress.kubernetes.io/auth-type\n\nannotation on the Ingress to \nbasic\n, and \ningress.kubernetes.io/auth-secret\n\nto the name of a secret which contains an htpasswd file as the \nauth\n key:\n\n\nmetadata:\n  annotations:\n    ingress.kubernetes.io/auth-type: basic\n    ingress.kubernetes.io/auth-secret: mysecret\n\n\n\n\nYou can create the necessary secret from an existing htpasswd file with \nkubectl\n:\n\n\n$ kubectl create secret generic mysecret --from-file=auth=my-htpasswd\n\n\n\n\nOptionally, set \ningress.kubernetes.io/auth-realm\n to the basic authentication\nrealm, which is displayed in the password prompt by most browsers.\n\n\nMost common password hash schemes are supported, including DES, MD5 (\n$1$\n and\n\n$apr1$\n), bcrypt (\n$2[abxy]$\n), SHA-256 (\n$5$\n) and SHA-512 (\n$6$\n), and four\nRFC2307-style hashes: \n{PLAIN}\n, \n{SHA}\n, \n{SSHA}\n and \n{CRYPT}\n (the first\nthree of which are also supported by nginx).\n\n\nSecurity-wise, although the MD5 schemes are extremely weak as password hashes,\nthey are probably fine for any situation where htpasswd-based authentication is\nin use.  The primary security improvement in newer algorithms (e.g. bcrypt and\nSHA-2) is they are slower, which increases the time required to perform an\noffline brute force attack; however, this also increases the time required to\n\ncheck\n the password, which leads to unacceptable delays on typical HTML page\nloads.\n\n\nFor example, if you use a bcrypt configuration that takes 200ms to check one\nhash, and you load an HTML page with 20 assets, then you will spend 4 seconds\ndoing nothing but waiting for authentication.  If multiple users are loading\npages at the same time, then things will be even slower once you run out of\nCPUs.\n\n\nIf you need stronger password security than MD5, you should stop using HTTP\nbasic authentication and use another authentication method (like Cookie-based\nauthentication) instead.\n\n\nIP address authentication\n\n\nTo enable IP authentication, set the\n\ningress.kubernetes.io/whitelist-source-range\n annotation to a comma-delimited\nlist of IP addresses or networks, for example \n\"127.0.0.0/8,::1/128\"\n.\n\n\nWhen both IP-based and password-authentication are configured on the same\ningress, you can set the \ningress.kubernetes.io/auth-satisfy\n annotation to\neither \nany\n or \nall\n:\n\n\n\n\n\n\nany\n will permit the request if either the IP is present in\n  \nwhitelist-source-range\n or if the client provides valid basic authentication;\n  otherwise the request will be denied with HTTP 401 Unauthorized.\n\n\n\n\n\n\nall\n will permit the request if the client IP is present in\n  \nwhitelist-source-range\n \nand\n the client also provides valid basic\n  authentication.  If the client IP address is not in the address list, the\n  request will be denied with HTTP 403 Forbidden.  If the IP address is present\n  but the request did not contain valid basic authentication, the request will\n  be denied with HTTP 401 Unauthorized.\n\n\n\n\n\n\nTo prevent accidental misconfiguration, the default value is \nall\n.\n\n\nImportant\n: IP address authentication requires that Traffic Server knows the\noriginal IP address of the client making the request.  If TS is serving requests\ndirectly, or sits behind a transparent load balancer that preserves the client\nIP address (such as an Azure service, a GCE network load balancer, or Linux LVS\nin some configurations), then this will be the case; otherwise, it will see all\nrequests as coming from the load balancer's internal IP address, and\nauthentication will not be effective.  We plan to address this limitation in a\nfuture release, using either the \nX-Forwarded-For\n header field, or the\nso-called Proxy Protocol.\n\n\nScalability note: The IP list is implemented as a simple linked list, rather\nthan a more efficient data structure such as a radix tree.  This means that the\nlookup time, and consequently the overall request time, will increase linearly\nas the number of entries in the list increases.\n\n\nThis decision was made because a linked list is a simpler data structure, and\ntherefore performs better with a small number of entries even though performance\nis worse with a larger list.  This trade-off will only become noticeable if you\nhave hundreds or thousands of entries in the address list, which is very\nunlikely in real-world deployments.  (For one thing, it would be extremely\ncumbersome to manage such a large list as an annotation.)\n\n\nIf you require support for such a large number of addresses in a single Ingress,\nplease let us know via a Github issue.",
            "title": "Authentication"
        },
        {
            "location": "/auth/#authentication",
            "text": "Authentication restricts who can request a particular page.  Authenticatian can\nbe done using HTTP basic authentication, where the client sends a username and\npassword in the request; by IP address, where only certain IP addresses are\npermitted to request the content; or by a combination of both.",
            "title": "Authentication"
        },
        {
            "location": "/auth/#password-authentication",
            "text": "To enable password authentication, set the  ingress.kubernetes.io/auth-type \nannotation on the Ingress to  basic , and  ingress.kubernetes.io/auth-secret \nto the name of a secret which contains an htpasswd file as the  auth  key:  metadata:\n  annotations:\n    ingress.kubernetes.io/auth-type: basic\n    ingress.kubernetes.io/auth-secret: mysecret  You can create the necessary secret from an existing htpasswd file with  kubectl :  $ kubectl create secret generic mysecret --from-file=auth=my-htpasswd  Optionally, set  ingress.kubernetes.io/auth-realm  to the basic authentication\nrealm, which is displayed in the password prompt by most browsers.  Most common password hash schemes are supported, including DES, MD5 ( $1$  and $apr1$ ), bcrypt ( $2[abxy]$ ), SHA-256 ( $5$ ) and SHA-512 ( $6$ ), and four\nRFC2307-style hashes:  {PLAIN} ,  {SHA} ,  {SSHA}  and  {CRYPT}  (the first\nthree of which are also supported by nginx).  Security-wise, although the MD5 schemes are extremely weak as password hashes,\nthey are probably fine for any situation where htpasswd-based authentication is\nin use.  The primary security improvement in newer algorithms (e.g. bcrypt and\nSHA-2) is they are slower, which increases the time required to perform an\noffline brute force attack; however, this also increases the time required to check  the password, which leads to unacceptable delays on typical HTML page\nloads.  For example, if you use a bcrypt configuration that takes 200ms to check one\nhash, and you load an HTML page with 20 assets, then you will spend 4 seconds\ndoing nothing but waiting for authentication.  If multiple users are loading\npages at the same time, then things will be even slower once you run out of\nCPUs.  If you need stronger password security than MD5, you should stop using HTTP\nbasic authentication and use another authentication method (like Cookie-based\nauthentication) instead.",
            "title": "Password authentication"
        },
        {
            "location": "/auth/#ip-address-authentication",
            "text": "To enable IP authentication, set the ingress.kubernetes.io/whitelist-source-range  annotation to a comma-delimited\nlist of IP addresses or networks, for example  \"127.0.0.0/8,::1/128\" .  When both IP-based and password-authentication are configured on the same\ningress, you can set the  ingress.kubernetes.io/auth-satisfy  annotation to\neither  any  or  all :    any  will permit the request if either the IP is present in\n   whitelist-source-range  or if the client provides valid basic authentication;\n  otherwise the request will be denied with HTTP 401 Unauthorized.    all  will permit the request if the client IP is present in\n   whitelist-source-range   and  the client also provides valid basic\n  authentication.  If the client IP address is not in the address list, the\n  request will be denied with HTTP 403 Forbidden.  If the IP address is present\n  but the request did not contain valid basic authentication, the request will\n  be denied with HTTP 401 Unauthorized.    To prevent accidental misconfiguration, the default value is  all .  Important : IP address authentication requires that Traffic Server knows the\noriginal IP address of the client making the request.  If TS is serving requests\ndirectly, or sits behind a transparent load balancer that preserves the client\nIP address (such as an Azure service, a GCE network load balancer, or Linux LVS\nin some configurations), then this will be the case; otherwise, it will see all\nrequests as coming from the load balancer's internal IP address, and\nauthentication will not be effective.  We plan to address this limitation in a\nfuture release, using either the  X-Forwarded-For  header field, or the\nso-called Proxy Protocol.  Scalability note: The IP list is implemented as a simple linked list, rather\nthan a more efficient data structure such as a radix tree.  This means that the\nlookup time, and consequently the overall request time, will increase linearly\nas the number of entries in the list increases.  This decision was made because a linked list is a simpler data structure, and\ntherefore performs better with a small number of entries even though performance\nis worse with a larger list.  This trade-off will only become noticeable if you\nhave hundreds or thousands of entries in the address list, which is very\nunlikely in real-world deployments.  (For one thing, it would be extremely\ncumbersome to manage such a large list as an annotation.)  If you require support for such a large number of addresses in a single Ingress,\nplease let us know via a Github issue.",
            "title": "IP address authentication"
        },
        {
            "location": "/external/",
            "text": "Proxying to external services\n\n\nSometimes, you might want to proxy traffic to a service that doesn't run as a\nKubernetes pod.  This can be used to expose external services via an Ingress,\nand to allow the \nfollow-redirects\n annotation to access external resources.\n\n\nExternal proxying via IP address\n\n\nTo proxy requests to a particular IP address or a set of IP address, create a\n\nService\n resource without a selector, and create its associated \nEndpoints\n\nresource:\n\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n\n---\n\nkind: Endpoints\napiVersion: v1\nmetadata:\n  name: external-service\nsubsets:\n- addresses:\n  - ip: 1.2.3.4\n  ports:\n  - port: 80\n\n\n\n\nYou can now define an Ingress to route traffic to this service:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80\n\n\n\n\nTraffic Server will now route requests for \nhttp://external.example.com/\n to your\nexternal service at IP address \n1.2.3.4\n.\n\n\nExternal proxying via hostname\n\n\nTo proxy to an external hostname, create a \nService\n resource of type\n\nExternalName\n:\n\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName\n  externalName: my-external-backend.example.com\n\n\n\n\nYou do not need to configure an \nEndpoints\n resource as with an external IP\naddress.  Create an Ingress for this Service:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\n  annotations:\n    ingress.torchbox.com/preserve-host: \"false\"\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80\n\n\n\n\nNow requests for \nhttp://external.example.com\n will be proxied to\n\nhttp://my-external-backend.example.com\n.\n\n\nWhen using an ExternalName Service, the \nservicePort\n must be an integer;\nnamed ports are not supported.\n\n\nIn most cases, you will want to set the \npreserve-host\n annotation to \n\"false\"\n\nso that the external service sees the hostname it's expecting, rather than the\nhostname in the client request.\n\n\nExternal proxying and TLS\n\n\nBy default, even if a request uses TLS, it will be proxied to the external\nbackend via HTTP.  To use TLS for the backend, set an annotation on the Ingress:\n\ningress.kubernetes.io/secure-backends: \"true\"\n.  This is not very useful for\nexternal IP addresses, because it's unlikely the backend will have a TLS\ncertificate for its IP address, but it will work well with \nExternalName\n\nservices.\n\n\nFor TLS to work, remember to set \nservicePort\n to \n443\n (or some other suitable\nvalue).",
            "title": "External proxying"
        },
        {
            "location": "/external/#proxying-to-external-services",
            "text": "Sometimes, you might want to proxy traffic to a service that doesn't run as a\nKubernetes pod.  This can be used to expose external services via an Ingress,\nand to allow the  follow-redirects  annotation to access external resources.",
            "title": "Proxying to external services"
        },
        {
            "location": "/external/#external-proxying-via-ip-address",
            "text": "To proxy requests to a particular IP address or a set of IP address, create a Service  resource without a selector, and create its associated  Endpoints \nresource:  kind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n\n---\n\nkind: Endpoints\napiVersion: v1\nmetadata:\n  name: external-service\nsubsets:\n- addresses:\n  - ip: 1.2.3.4\n  ports:\n  - port: 80  You can now define an Ingress to route traffic to this service:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80  Traffic Server will now route requests for  http://external.example.com/  to your\nexternal service at IP address  1.2.3.4 .",
            "title": "External proxying via IP address"
        },
        {
            "location": "/external/#external-proxying-via-hostname",
            "text": "To proxy to an external hostname, create a  Service  resource of type ExternalName :  kind: Service\napiVersion: v1\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName\n  externalName: my-external-backend.example.com  You do not need to configure an  Endpoints  resource as with an external IP\naddress.  Create an Ingress for this Service:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: external-ingress\n  annotations:\n    ingress.torchbox.com/preserve-host: \"false\"\nspec:\n  rules:\n  - host: external.example.com\n    http:\n      paths:\n      - backend:\n          serviceName: external-service\n          servicePort: 80  Now requests for  http://external.example.com  will be proxied to http://my-external-backend.example.com .  When using an ExternalName Service, the  servicePort  must be an integer;\nnamed ports are not supported.  In most cases, you will want to set the  preserve-host  annotation to  \"false\" \nso that the external service sees the hostname it's expecting, rather than the\nhostname in the client request.",
            "title": "External proxying via hostname"
        },
        {
            "location": "/external/#external-proxying-and-tls",
            "text": "By default, even if a request uses TLS, it will be proxied to the external\nbackend via HTTP.  To use TLS for the backend, set an annotation on the Ingress: ingress.kubernetes.io/secure-backends: \"true\" .  This is not very useful for\nexternal IP addresses, because it's unlikely the backend will have a TLS\ncertificate for its IP address, but it will work well with  ExternalName \nservices.  For TLS to work, remember to set  servicePort  to  443  (or some other suitable\nvalue).",
            "title": "External proxying and TLS"
        },
        {
            "location": "/tls/",
            "text": "Using TLS\n\n\nConfiguration\n\n\nTLS keys and certificates are taken from Kubernetes Secret resources according\nto \ntls\n attribute of each Ingress resource.  TLS Server Name Indication support\nis required for this to work; clients without SNI support will receive a TLS\nnegotiation error.\n\n\nIf you don't want to use Kubernetes for TLS, set \ntls: false\n in\n\nkubernetes.config\n or set the \n$TS_TLS\n environment variable to \n\"false\"\n.\nYou will need to provide TLS configuration some other way, like\n\nssl_multicert.config\n or the \nssl-cert-loader\n plugin, or else terminate TLS\nbefore traffic reaches Traffic Server.\n\n\nBy default, non-TLS HTTP requests to an Ingress host with TLS configured will\nbe 301 redirected to HTTPS.  To disable this behaviour, set the\n\ningress.kubernetes.io/ssl-redirect\n annotation to \nfalse\n.\n\n\nTo force a redirect to HTTPS even when TLS is not configured on the Ingress, set\nthe \ningress.kubernetes.io/force-ssl-redirect\n annotation to \n\"true\"\n.  This\nwill not work unless you are offloading TLS termination in front of Traffic\nServer.\n\n\nConnecting to pods via HTTPS\n\n\nUsually, communication between Traffic Server and backends (e.g. pods) is via\nnon-TLS HTTP, even if the request was made over HTTPS.  To use HTTPS to\ncommunicate with the backend, set the \ningress.kubernetes.io/secure-backends\n\nannotation to \n\"true\"\n.  This is not very useful when the backend is a pod,\nbecause TS connects to the pod by its IP address, and it's extremely unlikely\nthe pod will have a TLS certificate for that IP address.  However, this can be\nuseful when using external proxying (described below).\n\n\nA better method to secure traffic between Traffic Server and pods is to use a\nnetwork CNI plugin that supports encryption, such as Weave Net.\n\n\nHSTS\n\n\nTo enable HTTP Strict Transport Security (HSTS), set the\n\ningress.kubernetes.io/hsts-max-age\n annotation on the Ingress to the HSTS\nmax-age time in seconds.  To be useful, this should be set to at least six\nmonths (15768000 seconds), but you should start with a lower value and gradually\nincrease it.  Do not set it to a large value without testing it first, because,\nby design, it cannot be turned off for browsers that already saw the HSTS\nheader until the max-age expires.\n\n\nHSTS headers are per-hostname, not per-host.  Therefore, \nhsts-max-age\n can only\nbe set on the Ingress that includes the root path for a particular hostname\n(i.e., where the Ingress rule has no \npath\n attribute).\n\n\nTo apply HSTS to subdomains as well, set the\n\ningress.kubernetes.io/hsts-include-subdomains\n annotation.\n\n\nkube-lego\n\n\nkube-lego, a Kubernetes controller that automatically provisions TLS\ncertificates using an ACME provider such as Let's Encrypt, currently\n\ndoesn't support\n any\nIngress controllers other than nginx and GCE.  To use the TS Ingress controller\nwith kube-lego, you should tell it to handle the \n\"nginx\"\n Ingress class,\neither in \nkubernetes.config\n:\n\n\ningress_classes: trafficserver nginx\n\n\n\n\nOr by setting the \nTS_INGRESS_CLASSES\n environment variabe to\n\n\"trafficserver nginx\"\n.\n\n\nThen configure kube-lego as if you were using the nginx Ingress controller.",
            "title": "TLS"
        },
        {
            "location": "/tls/#using-tls",
            "text": "",
            "title": "Using TLS"
        },
        {
            "location": "/tls/#configuration",
            "text": "TLS keys and certificates are taken from Kubernetes Secret resources according\nto  tls  attribute of each Ingress resource.  TLS Server Name Indication support\nis required for this to work; clients without SNI support will receive a TLS\nnegotiation error.  If you don't want to use Kubernetes for TLS, set  tls: false  in kubernetes.config  or set the  $TS_TLS  environment variable to  \"false\" .\nYou will need to provide TLS configuration some other way, like ssl_multicert.config  or the  ssl-cert-loader  plugin, or else terminate TLS\nbefore traffic reaches Traffic Server.  By default, non-TLS HTTP requests to an Ingress host with TLS configured will\nbe 301 redirected to HTTPS.  To disable this behaviour, set the ingress.kubernetes.io/ssl-redirect  annotation to  false .  To force a redirect to HTTPS even when TLS is not configured on the Ingress, set\nthe  ingress.kubernetes.io/force-ssl-redirect  annotation to  \"true\" .  This\nwill not work unless you are offloading TLS termination in front of Traffic\nServer.",
            "title": "Configuration"
        },
        {
            "location": "/tls/#connecting-to-pods-via-https",
            "text": "Usually, communication between Traffic Server and backends (e.g. pods) is via\nnon-TLS HTTP, even if the request was made over HTTPS.  To use HTTPS to\ncommunicate with the backend, set the  ingress.kubernetes.io/secure-backends \nannotation to  \"true\" .  This is not very useful when the backend is a pod,\nbecause TS connects to the pod by its IP address, and it's extremely unlikely\nthe pod will have a TLS certificate for that IP address.  However, this can be\nuseful when using external proxying (described below).  A better method to secure traffic between Traffic Server and pods is to use a\nnetwork CNI plugin that supports encryption, such as Weave Net.",
            "title": "Connecting to pods via HTTPS"
        },
        {
            "location": "/tls/#hsts",
            "text": "To enable HTTP Strict Transport Security (HSTS), set the ingress.kubernetes.io/hsts-max-age  annotation on the Ingress to the HSTS\nmax-age time in seconds.  To be useful, this should be set to at least six\nmonths (15768000 seconds), but you should start with a lower value and gradually\nincrease it.  Do not set it to a large value without testing it first, because,\nby design, it cannot be turned off for browsers that already saw the HSTS\nheader until the max-age expires.  HSTS headers are per-hostname, not per-host.  Therefore,  hsts-max-age  can only\nbe set on the Ingress that includes the root path for a particular hostname\n(i.e., where the Ingress rule has no  path  attribute).  To apply HSTS to subdomains as well, set the ingress.kubernetes.io/hsts-include-subdomains  annotation.",
            "title": "HSTS"
        },
        {
            "location": "/tls/#kube-lego",
            "text": "kube-lego, a Kubernetes controller that automatically provisions TLS\ncertificates using an ACME provider such as Let's Encrypt, currently doesn't support  any\nIngress controllers other than nginx and GCE.  To use the TS Ingress controller\nwith kube-lego, you should tell it to handle the  \"nginx\"  Ingress class,\neither in  kubernetes.config :  ingress_classes: trafficserver nginx  Or by setting the  TS_INGRESS_CLASSES  environment variabe to \"trafficserver nginx\" .  Then configure kube-lego as if you were using the nginx Ingress controller.",
            "title": "kube-lego"
        }
    ]
}